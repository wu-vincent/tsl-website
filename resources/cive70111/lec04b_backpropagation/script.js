class BackpropagationDemo{constructor(){this.networkContainer=document.getElementById("network-container"),this.lossValueDisplay=document.getElementById("loss-value"),this.stepCountDisplay=document.getElementById("step-count"),this.lossCanvas=document.getElementById("loss-canvas"),this.lossChart=null,this.input1Slider=new ParamSlider("paramslider-input1",{inputId:"input1",label:"Input 1",min:-5,max:5,step:.1,value:1,decimals:1,onChange:()=>this.handleInputChange()}),this.input2Slider=new ParamSlider("paramslider-input2",{inputId:"input2",label:"Input 2",min:-5,max:5,step:.1,value:.5,decimals:1,onChange:()=>this.handleInputChange()}),this.targetSlider=new ParamSlider("paramslider-target",{inputId:"target",label:"Target Output",min:-5,max:5,step:.1,value:2,decimals:1,onChange:()=>this.handleInputChange()}),this.learningRateSlider=new ParamSlider("paramslider-learning-rate",{inputId:"learning-rate",label:"<strong>Learning Rate</strong>",min:0,max:1,step:.01,value:.01,decimals:2}),this.stepBtn=document.getElementById("step-btn"),this.autoBtn=document.getElementById("auto-btn"),this.resetBtn=document.getElementById("reset-btn"),this.historyScroll=document.getElementById("historyScroll"),this.historyStepRow=document.querySelector(".history-row-step"),this.historyLossRow=document.querySelector(".history-row-loss"),this.historyPredictionRow=document.querySelector(".history-row-prediction"),this.historyTargetRow=document.querySelector(".history-row-target"),this.historyDeltaLossRow=document.querySelector(".history-row-delta-loss"),this.architecture=[2,3,1],this.weights=[],this.activations=[],this.preActivations=[],this.gradients={weights:[]},this.stepCount=0,this.lossHistory=[],this.currentLoss=0,this.previousWeights=null,this.weightDeltas=null,this.highlightedConnection=null,this.isAnimating=!1,this.animationProgress=0,this.animationFrame=null,this.isAutoOptimizing=!1,this.autoOptimizationTimeout=null,this.lastLoss=null,this.nodePositions=[],this.initializeNetwork(),this.setupEventListeners(),this.infotab=new InfoTab,this.renderNetwork(),this.forwardPass(),this.updateVisualization(),this.initializeLossChart(),this.initializeHistoryTable()}initializeNetwork(){this.weights=[];for(let i=0;i<this.architecture.length-1;i++){const currentSize=this.architecture[i],nextSize=this.architecture[i+1],layerWeights=[];for(let j=0;j<nextSize;j++){const neuronWeights=[];for(let k=0;k<currentSize;k++){const limit=Math.sqrt(6/(currentSize+nextSize));neuronWeights.push((2*Math.random()-1)*limit)}layerWeights.push(neuronWeights)}this.weights.push(layerWeights)}this.gradients.weights=this.weights.map(layer=>layer.map(neuron=>neuron.map(()=>0)))}handleInputChange(){this.forwardPass(),this.backwardPass(),this.updateVisualization()}setupEventListeners(){console.log("Setting up event listeners"),console.log("stepBtn:",this.stepBtn),console.log("autoBtn:",this.autoBtn),console.log("resetBtn:",this.resetBtn),this.stepBtn.addEventListener("click",()=>this.stepOptimization()),this.autoBtn?this.autoBtn.addEventListener("click",()=>{console.log("Auto button clicked!"),this.toggleAutoOptimization()}):console.error("autoBtn not found!"),this.resetBtn.addEventListener("click",()=>this.resetNetwork())}getActivationIcon(activation){const iconMap={linear:'<svg viewBox="0 0 20 10"><line x1="0" y1="10" x2="20" y2="0" stroke="#666" stroke-width="1.5" fill="none"/></svg>',relu:'<svg viewBox="0 0 20 10"><path d="M 0 10 L 10 10 L 20 0" stroke="#666" stroke-width="1.5" fill="none"/></svg>',sigmoid:'<svg viewBox="0 0 20 10"><path d="M 0 9 Q 5 9, 10 5 T 20 1" stroke="#666" stroke-width="1.5" fill="none"/></svg>',tanh:'<svg viewBox="0 0 20 10"><path d="M 0 8 Q 5 8, 10 5 T 20 2" stroke="#666" stroke-width="1.5" fill="none"/></svg>'};return iconMap[activation]||iconMap.linear}getColorForValue(value,min,max){if(min===max)return value>=0?"#4caf50":"#f44336";let normalizedValue;if(value>=0){normalizedValue=max>0?value/max:0;return`rgb(${Math.round(200-124*normalizedValue)}, ${Math.round(230-55*normalizedValue)}, ${Math.round(201-121*normalizedValue)})`}normalizedValue=min<0?value/min:0;return`rgb(${Math.round(255-11*normalizedValue)}, ${Math.round(205-154*normalizedValue)}, ${Math.round(210-156*normalizedValue)})`}forwardPass(){const inputs=[this.input1Slider.getValue(),this.input2Slider.getValue()];this.activations=[inputs],this.preActivations=[inputs];for(let i=0;i<this.weights.length;i++){const currentActivations=this.activations[i],layerWeights=this.weights[i],nextPreActivations=[],nextActivations=[];for(let j=0;j<layerWeights.length;j++){let activation,sum=0;for(let k=0;k<currentActivations.length;k++)sum+=currentActivations[k]*layerWeights[j][k];nextPreActivations.push(sum),activation=i===this.weights.length-1?sum:Math.max(0,sum),nextActivations.push(activation)}this.preActivations.push(nextPreActivations),this.activations.push(nextActivations)}const prediction=this.activations[this.activations.length-1][0],targetValue=this.targetSlider.getValue(),target=isNaN(targetValue)?0:targetValue;this.currentLoss=.5*Math.pow(prediction-target,2)}backwardPass(){const targetValue=this.targetSlider.getValue(),target=isNaN(targetValue)?0:targetValue,deltaActivations=[],outputDelta=[this.activations[this.activations.length-1][0]-target];deltaActivations.push(outputDelta);for(let i=this.weights.length-1;i>=0;i--){const currentDeltas=deltaActivations[deltaActivations.length-1],layerWeights=this.weights[i];for(let j=0;j<layerWeights.length;j++)for(let k=0;k<layerWeights[j].length;k++)this.gradients.weights[i][j][k]=currentDeltas[j]*this.activations[i][k];if(i>0){const prevDeltas=[];for(let k=0;k<this.activations[i].length;k++){let delta=0;for(let j=0;j<layerWeights.length;j++)delta+=currentDeltas[j]*layerWeights[j][k];i>0&&(delta*=this.preActivations[i][k]>0?1:0),prevDeltas.push(delta)}deltaActivations.push(prevDeltas)}}}stepOptimization(){if(this.isAnimating)return;const learningRate=this.learningRateSlider.getValue(),previousLoss=this.currentLoss;this.previousWeights=this.weights.map(layer=>layer.map(neuron=>[...neuron])),this.weightDeltas=[];for(let i=0;i<this.weights.length;i++){this.weightDeltas[i]=[];for(let j=0;j<this.weights[i].length;j++){this.weightDeltas[i][j]=[];for(let k=0;k<this.weights[i][j].length;k++)this.weightDeltas[i][j][k]=-learningRate*this.gradients.weights[i][j][k]}}this.animateGradientFlow(()=>{for(let i=0;i<this.weights.length;i++)for(let j=0;j<this.weights[i].length;j++)for(let k=0;k<this.weights[i][j].length;k++)this.weights[i][j][k]+=this.weightDeltas[i][j][k];this.stepCount++,this.lossHistory.push(this.currentLoss),this.forwardPass(),this.backwardPass(),this.updateVisualization(),this.updateLossChart();const prediction=this.activations[this.activations.length-1][0],target=this.targetSlider.getValue(),deltaLoss=this.currentLoss-previousLoss;this.addHistoryColumn(this.stepCount,this.currentLoss,prediction,target,deltaLoss),this.updateWeightUpdatesDisplay(),this.lossHistory.length>100&&this.lossHistory.shift()})}toggleAutoOptimization(){console.log("toggleAutoOptimization called, isAutoOptimizing:",this.isAutoOptimizing),this.isAutoOptimizing?this.stopAutoOptimization():this.startAutoOptimization()}startAutoOptimization(){console.log("startAutoOptimization called"),this.isAutoOptimizing=!0,this.lastLoss=null,this.autoBtn.textContent="Stop Auto",this.autoBtn.style.background="#f44336",this.stepBtn.disabled=!0,this.resetBtn.disabled=!0,this.runAutoOptimizationStep()}stopAutoOptimization(){this.isAutoOptimizing=!1,this.autoOptimizationTimeout&&(clearTimeout(this.autoOptimizationTimeout),this.autoOptimizationTimeout=null),this.autoBtn.textContent="Auto Optim.",this.autoBtn.style.background="",this.stepBtn.disabled=!1,this.resetBtn.disabled=!1}runAutoOptimizationStep(){if(console.log("runAutoOptimizationStep called, isAutoOptimizing:",this.isAutoOptimizing,"isAnimating:",this.isAnimating,"lastLoss:",this.lastLoss,"currentLoss:",this.currentLoss),!this.isAutoOptimizing)return;if(this.isAnimating)return void(this.autoOptimizationTimeout=setTimeout(()=>{this.runAutoOptimizationStep()},100));this.currentLoss;this.stepOptimization(),this.autoOptimizationTimeout=setTimeout(()=>{if(null!==this.lastLoss&&Math.abs(this.currentLoss-this.lastLoss)<1e-6)return console.log("Loss converged, stopping auto-optimization. lastLoss:",this.lastLoss,"currentLoss:",this.currentLoss),void this.stopAutoOptimization();this.lastLoss=this.currentLoss,this.runAutoOptimizationStep()},200)}resetNetwork(){this.stopAutoOptimization(),this.initializeNetwork(),this.stepCount=0,this.lossHistory=[],this.lastLoss=null,this.forwardPass(),this.backwardPass(),this.updateVisualization(),this.updateLossChart(),this.clearHistoryTable()}renderNetwork(){this.networkContainer.innerHTML="";const containerWidth=this.networkContainer.clientWidth-10,containerHeight=this.networkContainer.clientHeight-10,layerSpacing=(containerHeight-60-80)/(this.architecture.length-1);this.nodePositions=[];const maxUnits=Math.max(...this.architecture),nodeSpacing=containerWidth/(maxUnits+1);this.architecture.forEach((layerSize,layerIndex)=>{const layerPositions=[],layerStartX=(containerWidth-(layerSize-1)*nodeSpacing)/2,layerLabel=document.createElement("div");layerLabel.className="network-layer-label-vertical",layerLabel.style.top=60+layerIndex*layerSpacing+10+"px",layerLabel.style.left="10px",0===layerIndex?layerLabel.textContent="Input":layerIndex===this.architecture.length-1?layerLabel.textContent="Output":layerLabel.textContent="Hidden",this.networkContainer.appendChild(layerLabel);for(let nodeIndex=0;nodeIndex<layerSize;nodeIndex++){const node=document.createElement("div"),typeClass=0===layerIndex?"input":layerIndex===this.architecture.length-1?"output":"hidden";node.className=`network-node ${typeClass}`,node.id=`node-${layerIndex}-${nodeIndex}`;const x=layerStartX+nodeIndex*nodeSpacing,y=60+layerIndex*layerSpacing-20;if(node.style.left=`${x}px`,node.style.top=`${y}px`,0===layerIndex||layerIndex===this.architecture.length-1){const valueSpan=document.createElement("span");valueSpan.style.background="white",valueSpan.style.border="1px solid white",valueSpan.style.borderRadius="3px",valueSpan.style.padding="1px 3px",valueSpan.style.fontSize="14px",valueSpan.style.fontWeight="bold",valueSpan.style.fontFamily="monospace",valueSpan.style.zIndex="10",valueSpan.style.position="relative",valueSpan.style.color=0===layerIndex?"#1976d2":"#388e3c",valueSpan.textContent="0.00",valueSpan.id=`value-${layerIndex}-${nodeIndex}`,node.appendChild(valueSpan)}else{const iconDiv=document.createElement("div");iconDiv.className="activation-icon",iconDiv.innerHTML=this.getActivationIcon("relu"),node.appendChild(iconDiv)}if(0!==layerIndex){const outputLabel=document.createElement("div");outputLabel.className="node-output-label",outputLabel.style.left=`${x+5}px`,outputLabel.style.top=`${y+75}px`,outputLabel.textContent="0.00",outputLabel.id=`output-${layerIndex}-${nodeIndex}`,this.networkContainer.appendChild(outputLabel)}node.addEventListener("mouseenter",e=>this.showNodeTooltip(e,layerIndex,nodeIndex)),node.addEventListener("mouseleave",()=>this.hideNodeTooltip()),layerPositions.push({x:x+30,y:y+30}),this.networkContainer.appendChild(node)}this.nodePositions.push(layerPositions)}),this.drawConnections()}drawConnections(){document.querySelectorAll(".network-edge").forEach(el=>el.remove());for(let layerIndex=0;layerIndex<this.architecture.length-1;layerIndex++){const currentPositions=this.nodePositions[layerIndex],nextPositions=this.nodePositions[layerIndex+1];currentPositions.forEach((fromPos,fromIndex)=>{nextPositions.forEach((toPos,toIndex)=>{const edge=document.createElement("div");edge.className="network-edge";const dx=toPos.x-fromPos.x,dy=toPos.y-fromPos.y,length=Math.sqrt(dx*dx+dy*dy),angle=Math.atan2(dy,dx);edge.style.left=`${fromPos.x}px`,edge.style.top=`${fromPos.y}px`,edge.style.width=`${length}px`,edge.style.transform=`rotate(${angle}rad)`,this.styleConnection(edge,layerIndex,toIndex,fromIndex),edge.dataset.layerIndex=layerIndex,edge.dataset.fromIndex=fromIndex,edge.dataset.toIndex=toIndex,edge.addEventListener("mouseenter",e=>this.showEdgeTooltip(e,layerIndex,fromIndex,toIndex)),edge.addEventListener("mouseleave",()=>this.hideEdgeTooltip()),this.networkContainer.appendChild(edge)})})}}styleConnection(edge,layerIndex,toIndex,fromIndex){const weight=this.weights[layerIndex][toIndex][fromIndex];let thickness=3;const connectionId=`${layerIndex}-${toIndex}-${fromIndex}`;let color;if(this.highlightedConnection===connectionId&&(thickness=6),0===this.stepCount)color="#000000";else{const transmittedValue=this.activations[layerIndex][fromIndex]*weight,layerTransmittedValues=[];for(let to=0;to<this.weights[layerIndex].length;to++)for(let from=0;from<this.weights[layerIndex][to].length;from++){const src=this.activations[layerIndex][from],w=this.weights[layerIndex][to][from];layerTransmittedValues.push(src*w)}const minTransmitted=Math.min(...layerTransmittedValues),maxTransmitted=Math.max(...layerTransmittedValues);color=this.getColorForValue(transmittedValue,minTransmitted,maxTransmitted)}edge.style.height=`${thickness}px`,edge.style.background=color,edge.style.opacity=this.highlightedConnection===connectionId?1:.9}updateVisualization(){const layerValueRanges=this.activations.map(values=>({min:Math.min(...values),max:Math.max(...values)}));this.activations.forEach((layerActivations,layerIdx)=>{layerActivations.forEach((activation,nodeIdx)=>{const valueSpan=document.getElementById(`value-${layerIdx}-${nodeIdx}`);valueSpan&&(valueSpan.textContent=activation.toFixed(2),valueSpan.style.background="white",valueSpan.style.border="1px solid white",valueSpan.style.color=0===layerIdx?"#1976d2":"#388e3c");const outputLabel=document.getElementById(`output-${layerIdx}-${nodeIdx}`);outputLabel&&(outputLabel.textContent=activation.toFixed(2));const nodeEl=document.getElementById(`node-${layerIdx}-${nodeIdx}`);if(nodeEl){let color;if(0===layerIdx)color=this.getColorForValue(activation,-5,5);else{const range=layerValueRanges[layerIdx];color=this.getColorForValue(activation,range.min,range.max)}nodeEl.style.boxShadow=`inset 0 0 0 6px ${color}`}})}),this.drawConnections(),this.updateTables(),this.lossValueDisplay.textContent=this.currentLoss.toFixed(4),this.stepCountDisplay.textContent=this.stepCount}updateTables(){this.updateWeightsTable(),this.updateGradientsTable()}updateWeightsTable(){const container=document.getElementById("weights-table");if(!container)return;let html="";html+='<div class="layer-section">\n            <div class="layer-title">Weights</div>\n            <div class="weights-grid">\n                <div class="column-header">From I1</div>\n                <div class="column-header">From I2</div>\n                <div class="column-header">To Output</div>\n\n                <div class="column-data">';for(let toIndex=0;toIndex<3;toIndex++){const weight=this.weights[0][toIndex][0];html+=`<div class="weight-row"\n                onmouseover="demo.highlightConnection(0, ${toIndex}, 0)"\n                onmouseout="demo.clearHighlight()">\n                <span>→ H${toIndex+1}:</span>\n                <span class="connection-value ${weight>=0?"positive-value":"negative-value"}">${weight.toFixed(3)}</span>\n            </div>`}html+='</div><div class="column-data">';for(let toIndex=0;toIndex<3;toIndex++){const weight=this.weights[0][toIndex][1];html+=`<div class="weight-row"\n                onmouseover="demo.highlightConnection(0, ${toIndex}, 1)"\n                onmouseout="demo.clearHighlight()">\n                <span>→ H${toIndex+1}:</span>\n                <span class="connection-value ${weight>=0?"positive-value":"negative-value"}">${weight.toFixed(3)}</span>\n            </div>`}html+='</div><div class="column-data">';for(let fromIndex=0;fromIndex<3;fromIndex++){const weight=this.weights[1][0][fromIndex];html+=`<div class="weight-row"\n                onmouseover="demo.highlightConnection(1, 0, ${fromIndex})"\n                onmouseout="demo.clearHighlight()">\n                <span>H${fromIndex+1} →:</span>\n                <span class="connection-value ${weight>=0?"positive-value":"negative-value"}">${weight.toFixed(3)}</span>\n            </div>`}html+="</div></div></div>",html+='<div style="padding: 10px 5px; font-size: 11px; color: #666; font-style: italic; text-align: center;">\n            Note: For simplicity, this network does not have any biases\n        </div>',container.innerHTML=html}updateGradientsTable(){const container=document.getElementById("gradients-table");if(!container)return;let html="";html+='<div class="layer-section">\n            <div class="layer-title">Input → Hidden Gradients</div>\n            <div class="weights-grid">\n                <div class="column-header">From I1</div>\n                <div class="column-header">From I2</div>\n                <div class="column-header">Hidden → Output</div>\n                \n                <div class="column-data">';for(let toIndex=0;toIndex<3;toIndex++){const gradient=this.gradients.weights[0][toIndex][0],valueClass=gradient>=0?"positive-value":"negative-value";Math.abs(gradient);html+=`<div class="${"gradient-row"}" \n                onmouseover="demo.highlightConnection(0, ${toIndex}, 0)"\n                onmouseout="demo.clearHighlight()">\n                <span>→ H${toIndex+1}:</span>\n                <span class="connection-value ${valueClass}">${gradient.toFixed(3)}</span>\n            </div>`}html+='</div><div class="column-data">';for(let toIndex=0;toIndex<3;toIndex++){const gradient=this.gradients.weights[0][toIndex][1],valueClass=gradient>=0?"positive-value":"negative-value";Math.abs(gradient);html+=`<div class="${"gradient-row"}" \n                onmouseover="demo.highlightConnection(0, ${toIndex}, 1)"\n                onmouseout="demo.clearHighlight()">\n                <span>→ H${toIndex+1}:</span>\n                <span class="connection-value ${valueClass}">${gradient.toFixed(3)}</span>\n            </div>`}html+='</div><div class="column-data">';for(let fromIndex=0;fromIndex<3;fromIndex++){const gradient=this.gradients.weights[1][0][fromIndex],valueClass=gradient>=0?"positive-value":"negative-value";Math.abs(gradient);html+=`<div class="${"gradient-row"}" \n                onmouseover="demo.highlightConnection(1, 0, ${fromIndex})"\n                onmouseout="demo.clearHighlight()">\n                <span>H${fromIndex+1} →:</span>\n                <span class="connection-value ${valueClass}">${gradient.toFixed(3)}</span>\n            </div>`}html+="</div></div></div>",container.innerHTML=html}highlightConnection(layerIndex,toIndex,fromIndex){this.highlightedConnection=`${layerIndex}-${toIndex}-${fromIndex}`,this.drawConnections()}clearHighlight(){this.highlightedConnection=null,this.drawConnections()}initializeLossChart(){this.lossChart=new Chart(this.lossCanvas.getContext("2d"),{type:"line",data:{labels:[],datasets:[{label:"MSE Loss",data:[],borderColor:"#dc3545",backgroundColor:"rgba(220, 53, 69, 0.1)",borderWidth:2,fill:!1,tension:.1,pointRadius:3,pointBackgroundColor:"#dc3545",pointBorderColor:"#dc3545"}]},options:{responsive:!0,maintainAspectRatio:!1,scales:{x:{title:{display:!0,text:"Training Steps"},grid:{color:"#ddd"}},y:{title:{display:!0,text:"MSE Loss"},grid:{color:"#ddd"},beginAtZero:!1}},plugins:{legend:{display:!1},title:{display:!0,text:"MSE Loss Over Time",font:{size:14}}},interaction:{intersect:!1,mode:"index"},animation:{duration:0}}})}updateLossChart(){if(!this.lossChart)return;const labels=this.lossHistory.map((_,index)=>index);this.lossChart.data.labels=labels,this.lossChart.data.datasets[0].data=this.lossHistory,this.lossChart.update("none")}showEdgeTooltip(event,layerIndex,fromIndex,toIndex){const weight=this.weights[layerIndex][toIndex][fromIndex],sourceValue=this.activations[layerIndex][fromIndex],transmittedValue=sourceValue*weight;let tooltip=document.getElementById("edge-tooltip");tooltip||(tooltip=document.createElement("div"),tooltip.id="edge-tooltip",tooltip.className="edge-tooltip",document.body.appendChild(tooltip)),tooltip.innerHTML=`\n            <div><strong>Weight:</strong> ${weight.toFixed(3)}</div>\n            <div><strong>Input:</strong> ${sourceValue.toFixed(3)}</div>\n            <div><strong>Output:</strong> ${transmittedValue.toFixed(3)}</div>\n        `,tooltip.style.left=`${event.pageX+10}px`,tooltip.style.top=`${event.pageY+10}px`,tooltip.style.display="block"}hideEdgeTooltip(){const tooltip=document.getElementById("edge-tooltip");tooltip&&(tooltip.style.display="none")}showNodeTooltip(event,layerIndex,nodeIndex){let tooltip=document.getElementById("node-tooltip");tooltip||(tooltip=document.createElement("div"),tooltip.id="node-tooltip",tooltip.className="node-tooltip",document.body.appendChild(tooltip));let content="";if(0===layerIndex){content=`\n                <div><strong>Input Node ${nodeIndex+1}</strong></div>\n                <div>Value: ${this.activations[layerIndex][nodeIndex].toFixed(3)}</div>\n            `}else{const z=this.preActivations[layerIndex][nodeIndex],a=this.activations[layerIndex][nodeIndex],activation=layerIndex===this.architecture.length-1?"linear":"relu",weights=this.weights[layerIndex-1][nodeIndex],prevLayerValues=this.activations[layerIndex-1];content=`\n                <div><strong>${layerIndex===this.architecture.length-1?"Output":"Hidden"} Node ${nodeIndex+1}</strong></div>\n                <div style="margin-top: 6px;"><strong>Inputs:</strong></div>\n            `;for(let i=0;i<weights.length;i++){const inputValue=prevLayerValues[i],contribution=inputValue*weights[i];content+=`<div style="margin-left: 10px;">x${i+1} = ${inputValue.toFixed(3)} × w${i+1} = ${contribution.toFixed(3)}</div>`}content+=`\n                <div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid #ddd;">\n                    <strong>z</strong> (pre-activation) = ${z.toFixed(3)}\n                </div>\n                <div style="margin-top: 4px;">\n                    <strong>a</strong> (post-activation) = ${activation}(z) = ${a.toFixed(3)}\n                </div>\n            `}tooltip.innerHTML=content,tooltip.style.left=`${event.pageX+15}px`,tooltip.style.top=`${event.pageY+15}px`,tooltip.style.display="block"}hideNodeTooltip(){const tooltip=document.getElementById("node-tooltip");tooltip&&(tooltip.style.display="none")}initializeHistoryTable(){const prediction=this.activations[this.activations.length-1][0],target=this.targetSlider.getValue();this.historyStepRow.children[1].textContent="0",this.historyLossRow.children[1].textContent=this.currentLoss.toFixed(4),this.historyPredictionRow.children[1].textContent=prediction.toFixed(3),this.historyTargetRow.children[1].textContent=target.toFixed(3),this.historyDeltaLossRow.children[1].textContent="—",this.historyStepRow.children[1].classList.add("current-iteration"),this.historyLossRow.children[1].classList.add("current-iteration"),this.historyPredictionRow.children[1].classList.add("current-iteration"),this.historyTargetRow.children[1].classList.add("current-iteration"),this.historyDeltaLossRow.children[1].classList.add("current-iteration")}addHistoryColumn(step,loss,prediction,target,deltaLoss){document.querySelectorAll(".horizontal-scroll-table td.current-iteration").forEach(cell=>{cell.classList.remove("current-iteration")});const stepCell=document.createElement("td");stepCell.textContent=step,stepCell.classList.add("current-iteration"),this.historyStepRow.appendChild(stepCell);const lossCell=document.createElement("td");lossCell.textContent=loss.toFixed(4),lossCell.classList.add("current-iteration"),this.historyLossRow.appendChild(lossCell);const predictionCell=document.createElement("td");predictionCell.textContent=prediction.toFixed(3),predictionCell.classList.add("current-iteration"),this.historyPredictionRow.appendChild(predictionCell);const targetCell=document.createElement("td");targetCell.textContent=target.toFixed(3),targetCell.classList.add("current-iteration"),this.historyTargetRow.appendChild(targetCell);const deltaLossCell=document.createElement("td");deltaLossCell.textContent=deltaLoss.toFixed(4),deltaLossCell.classList.add("current-iteration"),this.historyDeltaLossRow.appendChild(deltaLossCell),this.historyScroll.scrollLeft=this.historyScroll.scrollWidth}animateGradientFlow(callback){if(this.isAutoOptimizing)return void(callback&&callback());const canvas=document.getElementById("gradient-flow-canvas");if(!canvas)return void(callback&&callback());const ctx=canvas.getContext("2d"),rect=this.networkContainer.getBoundingClientRect();canvas.width=rect.width,canvas.height=rect.height,this.isAnimating=!0,this.animationProgress=0;const startTime=Date.now(),animate=()=>{const elapsed=Date.now()-startTime;this.animationProgress=Math.min(elapsed/1500,1),ctx.clearRect(0,0,canvas.width,canvas.height),this.drawGradientFlowParticles(ctx),this.animationProgress<1?this.animationFrame=requestAnimationFrame(animate):(this.isAnimating=!1,ctx.clearRect(0,0,canvas.width,canvas.height),callback&&callback())};animate()}drawGradientFlowParticles(ctx){const layer1Progress=Math.max(0,Math.min(1,2*this.animationProgress));layer1Progress>0&&this.drawLayerGradientFlow(ctx,1,layer1Progress,"#e91e63");const layer0Progress=Math.max(0,Math.min(1,2*(this.animationProgress-.5)));layer0Progress>0&&this.drawLayerGradientFlow(ctx,0,layer0Progress,"#9c27b0")}drawLayerGradientFlow(ctx,layerIndex,progress,color){const currentPositions=this.nodePositions[layerIndex];this.nodePositions[layerIndex+1].forEach((toPos,toIndex)=>{currentPositions.forEach((fromPos,fromIndex)=>{const gradient=Math.abs(this.gradients.weights[layerIndex][toIndex][fromIndex]);if(gradient<.001)return;for(let p=0;p<3;p++){let particleProgress=(progress+p/3)%1;const x=toPos.x+(fromPos.x-toPos.x)*particleProgress,y=toPos.y+(fromPos.y-toPos.y)*particleProgress,radius=3+4*(gradient/(Math.max(...this.gradients.weights[layerIndex].flat().map(Math.abs))+.001));ctx.beginPath(),ctx.arc(x,y,radius,0,2*Math.PI),ctx.fillStyle=color,ctx.globalAlpha=.6*(1-.5*particleProgress),ctx.fill(),ctx.globalAlpha=1;const trailX=x+.1*(toPos.x-fromPos.x),trailY=y+.1*(toPos.y-fromPos.y);ctx.beginPath(),ctx.moveTo(x,y),ctx.lineTo(trailX,trailY),ctx.strokeStyle=color,ctx.lineWidth=.5*radius,ctx.globalAlpha=.3*(1-.5*particleProgress),ctx.stroke(),ctx.globalAlpha=1}})})}updateWeightUpdatesDisplay(){const container=document.getElementById("weight-updates-display");if(!container||!this.previousWeights||!this.weightDeltas)return;const updates=[],layerNames=["Input→Hidden","Hidden→Output"];for(let i=0;i<this.weights.length;i++)for(let j=0;j<this.weights[i].length;j++)for(let k=0;k<this.weights[i][j].length;k++){const oldWeight=this.previousWeights[i][j][k],newWeight=this.weights[i][j][k],delta=this.weightDeltas[i][j][k],absChange=Math.abs(delta);let label;label=0===i?`I${k+1}→H${j+1}`:`H${k+1}→O`,updates.push({label:label,layer:layerNames[i],oldWeight:oldWeight,newWeight:newWeight,delta:delta,absChange:absChange})}updates.sort((a,b)=>b.absChange-a.absChange);let html='<div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;">';updates.forEach(update=>{update.delta;const arrow=update.delta>0?"↑":update.delta<0?"↓":"−",changeSymbol=update.delta>0?"+":"";let borderColor,deltaColor;0===update.delta?(borderColor="#999",deltaColor="#999"):update.delta>0?(borderColor="#2196f3",deltaColor="#2196f3"):(borderColor="#ff9800",deltaColor="#ff9800"),html+=`\n                <div style="background: white; padding: 8px; border-left: 3px solid ${borderColor}; display: grid; grid-template-columns: auto 1fr auto; align-items: center; gap: 12px;">\n                    <div style="font-weight: bold; color: #333; font-size: 16px;">\n                        ${update.label}\n                    </div>\n                    <div style="display: flex; flex-direction: column; gap: 1px; font-size: 11px;">\n                        <div style="color: #666;">\n                            Before: ${update.oldWeight.toFixed(4)}\n                        </div>\n                        <div style="color: #666;">\n                            After: ${update.newWeight.toFixed(4)}\n                        </div>\n                    </div>\n                    <div style="color: ${deltaColor}; font-size: 13px; font-weight: bold; white-space: nowrap; text-align: right;">\n                        Δw = ${changeSymbol}${update.delta.toFixed(3)} ${arrow}\n                    </div>\n                </div>\n            `}),html+="</div>",container.innerHTML=html}clearHistoryTable(){for(;this.historyStepRow.children.length>2;)this.historyStepRow.removeChild(this.historyStepRow.lastChild);for(;this.historyLossRow.children.length>2;)this.historyLossRow.removeChild(this.historyLossRow.lastChild);for(;this.historyPredictionRow.children.length>2;)this.historyPredictionRow.removeChild(this.historyPredictionRow.lastChild);for(;this.historyTargetRow.children.length>2;)this.historyTargetRow.removeChild(this.historyTargetRow.lastChild);for(;this.historyDeltaLossRow.children.length>2;)this.historyDeltaLossRow.removeChild(this.historyDeltaLossRow.lastChild);this.initializeHistoryTable()}}document.addEventListener("DOMContentLoaded",()=>{window.demo=new BackpropagationDemo});