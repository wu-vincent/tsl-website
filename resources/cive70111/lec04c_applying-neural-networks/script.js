const state={currentDataset:"structures",trainData:null,testData:null,normParams:null,hiddenLayers:[{units:4,activation:"relu"}],model:null,linearModel:null,trainingHistory:[],currentEpoch:0,learningRate:.01,isTraining:!1,lossChart:null,infotab:null,hoveredEdge:null,hoveredNode:null},datasetMetadata={structures:{name:"Concrete Compressive Strength",features:["Cement","Superplasticizer","Age","Water"],target:"Strength",units:{Cement:"kg/m³",Superplasticizer:"kg/m³",Age:"days",Water:"kg/m³",Strength:"MPa"},description:"Predict concrete compressive strength from mix design parameters. 4 features, 948 samples.",featureDesc:"Features: Cement content, superplasticizer amount, concrete age, and water content",targetDesc:"Target: Compressive strength in megapascals (MPa)"},environment:{name:"Wastewater Treatment Performance",features:["Nitrogen","Ammonia","Temperature","Inflow"],target:"BOD",units:{Nitrogen:"mg/L",Ammonia:"mg/L",Temperature:"°C",Inflow:"m³/s",BOD:"mg/L"},description:"Predict biological oxygen demand in wastewater treatment. 4 features, 1156 samples.",featureDesc:"Features: Total nitrogen, ammonia concentration, water temperature, and inflow rate",targetDesc:"Target: Biological oxygen demand (BOD) in mg/L"},transport:{name:"Electric Vehicle Pricing",features:["Top_Speed","Fastcharge","0-100","Battery"],target:"UK_price",units:{Top_Speed:"km/h",Fastcharge:"km/h","0-100":"seconds",Battery:"kWh",UK_price:"£"},description:"Predict EV pricing from performance characteristics. 4 features, 353 samples.",featureDesc:"Features: Top speed, fast charge speed, 0-100 km/h acceleration time, and battery capacity",targetDesc:"Target: UK retail price in pounds sterling (£)"},geotechnics:{name:"Soil Uniformity Coefficient",features:["dmax","Gr","Sa","Cl"],target:"CU",units:{dmax:"mm",Gr:"%",Sa:"%",Cl:"%",CU:"dimensionless"},description:"Predict soil gradation uniformity from particle distribution. 4 features, 189 samples.",featureDesc:"Features: Maximum grain size, gravel content, sand content, and clay content",targetDesc:"Target: Coefficient of uniformity (CU), a dimensionless measure of grain size distribution"}};let learningRateSlider,epochsSlider;function initializeInfoTabs(){"undefined"!=typeof InfoTab&&new InfoTab;const demoTabButtons=document.querySelectorAll(".demo-tab-button"),demoTabContents=document.querySelectorAll(".demo-tab-content");demoTabButtons.forEach(button=>{button.addEventListener("click",()=>{const tabName=button.dataset.tab;demoTabButtons.forEach(btn=>btn.classList.remove("active")),button.classList.add("active"),demoTabContents.forEach(content=>{content.dataset.tab===tabName?content.classList.add("active"):content.classList.remove("active")})})})}async function loadDataset(datasetName){state.currentDataset=datasetName;const loadingIndicator=document.getElementById("loadingIndicator"),datasetInfo=document.getElementById("datasetInfo");loadingIndicator&&loadingIndicator.classList.remove("hidden"),datasetInfo&&(datasetInfo.classList.remove("show"),datasetInfo.innerHTML="");try{if(!state.normParams){const normResponse=await fetch("example-data/normalization_params.json");state.normParams=await normResponse.json()}const[trainResponse,testResponse]=await Promise.all([fetch(`example-data/${datasetName}_train.csv`),fetch(`example-data/${datasetName}_test.csv`)]),trainCSV=await trainResponse.text(),testCSV=await testResponse.text();state.trainData=parseCSV(trainCSV),state.testData=parseCSV(testCSV),updateDatasetInfo(),resetTraining()}catch(error){console.error("Error loading dataset:",error),alert("Failed to load dataset. Please check console for details.")}finally{loadingIndicator&&loadingIndicator.classList.add("hidden")}}function parseCSV(csvText){const lines=csvText.trim().split("\n"),headers=lines[0].split(",").map(h=>h.trim()),data=[];for(let i=1;i<lines.length;i++){const values=lines[i].split(",").map(v=>parseFloat(v.trim())),row={};headers.forEach((header,idx)=>{row[header]=values[idx]}),data.push(row)}return{headers:headers,data:data}}function updateDatasetInfo(){const metadata=datasetMetadata[state.currentDataset],infoDiv=document.getElementById("datasetInfo");infoDiv&&(infoDiv.innerHTML=`\n        <strong>${metadata.name}</strong><br>\n        ${metadata.description}<br>\n        ${metadata.featureDesc}<br>\n        ${metadata.targetDesc}<br>\n        <em>Note: All data is pre-normalized (mean=0, std=1)</em>\n    `,infoDiv.classList.add("show"),updatePredictionInputs())}function initializeArchitectureControls(){updateLayerControls(),updateLayerCount()}function updateLayerControls(){const container=document.getElementById("layerControls");container.innerHTML="",state.hiddenLayers.forEach((layer,idx)=>{const layerDiv=document.createElement("div");layerDiv.className="layer-control layer-control--enter",layerDiv.innerHTML=`\n            <span>Layer ${idx+1}:</span>\n            <label>Units:</label>\n            <input type="number" class="layer-units" data-layer="${idx}"\n                   value="${layer.units}" min="1" max="10">\n            <label>Activation:</label>\n            <select class="layer-activation" data-layer="${idx}">\n                <option value="linear" ${"linear"===layer.activation?"selected":""}>Linear</option>\n                <option value="relu" ${"relu"===layer.activation?"selected":""}>ReLU</option>\n                <option value="sigmoid" ${"sigmoid"===layer.activation?"selected":""}>Sigmoid</option>\n                <option value="tanh" ${"tanh"===layer.activation?"selected":""}>Tanh</option>\n            </select>\n        `,container.appendChild(layerDiv)}),document.querySelectorAll(".layer-units").forEach(input=>{input.addEventListener("change",e=>{const layerIdx=parseInt(e.target.dataset.layer);state.hiddenLayers[layerIdx].units=parseInt(e.target.value),resetTraining()})}),document.querySelectorAll(".layer-activation").forEach(select=>{select.addEventListener("change",e=>{const layerIdx=parseInt(e.target.dataset.layer);state.hiddenLayers[layerIdx].activation=e.target.value,resetTraining()})})}function updateLayerCount(){document.getElementById("layerCount").textContent=`Hidden Layers: ${state.hiddenLayers.length}`,document.getElementById("addLayerBtn").disabled=state.hiddenLayers.length>=3,document.getElementById("removeLayerBtn").disabled=state.hiddenLayers.length<=1}function buildModel(){if(state.model&&state.model.dispose(),!state.trainData)return;const numFeatures=datasetMetadata[state.currentDataset].features.length,model=tf.sequential();state.hiddenLayers.forEach((layer,idx)=>{0===idx?model.add(tf.layers.dense({units:layer.units,activation:layer.activation,inputShape:[numFeatures]})):model.add(tf.layers.dense({units:layer.units,activation:layer.activation}))}),model.add(tf.layers.dense({units:1,activation:"linear"})),model.compile({optimizer:tf.train.adam(state.learningRate),loss:"meanSquaredError"}),state.model=model,updateNetworkDiagram()}function getModelWeights(){if(!state.model)return[];const weights=[];return state.model.layers.forEach(layer=>{const layerWeights=layer.getWeights();layerWeights.length>0&&weights.push({weights:layerWeights[0].arraySync(),biases:layerWeights[1].arraySync()})}),weights}async function trainEpochs(){if(!state.model||!state.trainData||state.isTraining)return;const numEpochs=epochsSlider?epochsSlider.getValue():20;state.isTraining=!0,document.getElementById("trainBtn").disabled=!0;try{const metadata=datasetMetadata[state.currentDataset],X=state.trainData.data.map(row=>metadata.features.map(feat=>row[feat])),y=state.trainData.data.map(row=>[row[metadata.target]]),xs=tf.tensor2d(X),ys=tf.tensor2d(y),newLearningRate=learningRateSlider?learningRateSlider.getValue():.01;newLearningRate!==state.learningRate&&(state.learningRate=newLearningRate,state.model.compile({optimizer:tf.train.adam(state.learningRate),loss:"meanSquaredError"}));for(let i=0;i<numEpochs;i++){const history=await state.model.fit(xs,ys,{epochs:1,shuffle:!0,verbose:0});state.currentEpoch++;const loss=history.history.loss[0];state.trainingHistory.push(loss),document.getElementById("epochDisplay").textContent=state.currentEpoch,document.getElementById("lossDisplay").textContent=loss.toFixed(6),updateLossChart(),i===numEpochs-1&&updateNetworkDiagram()}xs.dispose(),ys.dispose()}catch(error){console.error("Training error:",error),alert("Training failed. Check console for details.")}finally{state.isTraining=!1,document.getElementById("trainBtn").disabled=!1}}function resetTraining(){state.trainingHistory=[],state.currentEpoch=0,document.getElementById("epochDisplay").textContent="0",document.getElementById("lossDisplay").textContent="-",buildModel(),updateLossChart(),updateNetworkDiagram()}function clearHistory(){state.trainingHistory=[],state.currentEpoch=0,document.getElementById("epochDisplay").textContent="0",document.getElementById("lossDisplay").textContent="-",updateLossChart()}function trainLinearRegression(){if(!state.trainData)return null;const metadata=datasetMetadata[state.currentDataset],X=state.trainData.data.map(row=>metadata.features.map(feat=>row[feat])),y=state.trainData.data.map(row=>row[metadata.target]),X_bias=X.map(row=>[1,...row]),Xt=transpose(X_bias),XtX_inv=matrixInverse(matrixMultiply(Xt,X_bias));if(null===XtX_inv)return console.error("Failed to train linear regression: singular matrix"),null;const Xty=matrixVectorMultiply(Xt,y);return matrixVectorMultiply(XtX_inv,Xty)}function predictLinearRegression(theta,features){return[1,...features].reduce((sum,val,idx)=>sum+val*theta[idx],0)}function transpose(matrix){return matrix[0].map((_,colIdx)=>matrix.map(row=>row[colIdx]))}function matrixMultiply(A,B){const result=[];for(let i=0;i<A.length;i++){result[i]=[];for(let j=0;j<B[0].length;j++){let sum=0;for(let k=0;k<A[0].length;k++)sum+=A[i][k]*B[k][j];result[i][j]=sum}}return result}function matrixVectorMultiply(matrix,vector){return matrix.map(row=>row.reduce((sum,val,idx)=>sum+val*vector[idx],0))}function matrixInverse(matrix){const n=matrix.length,augmented=matrix.map((row,i)=>{const identity=new Array(n).fill(0);return identity[i]=1,[...row,...identity]});for(let i=0;i<n;i++){let maxRow=i;for(let k=i+1;k<n;k++)Math.abs(augmented[k][i])>Math.abs(augmented[maxRow][i])&&(maxRow=k);[augmented[i],augmented[maxRow]]=[augmented[maxRow],augmented[i]];const pivot=augmented[i][i];if(Math.abs(pivot)<1e-9)return console.error("Matrix is singular and cannot be inverted."),null;for(let j=0;j<2*n;j++)augmented[i][j]/=pivot;for(let k=0;k<n;k++)if(k!==i){const factor=augmented[k][i];for(let j=0;j<2*n;j++)augmented[k][j]-=factor*augmented[i][j]}}return augmented.map(row=>row.slice(n))}async function evaluateModels(){if(!state.model||!state.testData)return;const metadata=datasetMetadata[state.currentDataset],X_test=state.testData.data.map(row=>metadata.features.map(feat=>row[feat])),y_test=state.testData.data.map(row=>row[metadata.target]),xs_test=tf.tensor2d(X_test),nn_preds_tensor=state.model.predict(xs_test),nn_preds=await nn_preds_tensor.data();xs_test.dispose(),nn_preds_tensor.dispose();const lr_theta=trainLinearRegression();if(null===lr_theta)return void alert("Linear regression failed: singular matrix. Cannot evaluate baseline.");const lr_preds=X_test.map(x=>predictLinearRegression(lr_theta,x)),nn_metrics=calculateMetrics(y_test,Array.from(nn_preds)),lr_metrics=calculateMetrics(y_test,lr_preds);document.getElementById("nnMSE").textContent=nn_metrics.mse.toFixed(4),document.getElementById("nnMAE").textContent=nn_metrics.mae.toFixed(4),document.getElementById("nnR2").textContent=nn_metrics.r2.toFixed(4),document.getElementById("lrMSE").textContent=lr_metrics.mse.toFixed(4),document.getElementById("lrMAE").textContent=lr_metrics.mae.toFixed(4),document.getElementById("lrR2").textContent=lr_metrics.r2.toFixed(4);const notesDiv=document.getElementById("evaluationNotes");let notes="<strong>Interpretation:</strong><br>";if(0===state.currentEpoch?notes+="⚠️ Neural network has not been trained yet. Metrics reflect random initial weights.<br>":notes+=`Neural network trained for ${state.currentEpoch} epoch(s).<br>`,nn_metrics.r2>lr_metrics.r2){notes+=`✓ Neural network shows ${((nn_metrics.r2-lr_metrics.r2)/lr_metrics.r2*100).toFixed(1)}% better R² than linear regression.`}else notes+="Linear regression performs better. Try training the neural network for more epochs.";notesDiv.innerHTML=notes,state.linearModel=lr_theta}function calculateMetrics(y_true,y_pred){const n=y_true.length,mse=y_true.reduce((sum,yt,i)=>sum+Math.pow(yt-y_pred[i],2),0)/n,mae=y_true.reduce((sum,yt,i)=>sum+Math.abs(yt-y_pred[i]),0)/n,y_mean=y_true.reduce((sum,yt)=>sum+yt,0)/n,ss_tot=y_true.reduce((sum,yt)=>sum+Math.pow(yt-y_mean,2),0),ss_res=y_true.reduce((sum,yt,i)=>sum+Math.pow(yt-y_pred[i],2),0);return{mse:mse,mae:mae,r2:ss_tot>0?1-ss_res/ss_tot:ss_res>0?0:1}}document.addEventListener("DOMContentLoaded",async()=>{await tf.ready(),learningRateSlider=new ParamSlider("paramslider-learning-rate",{inputId:"learning-rate",label:"Learning Rate",min:1e-4,max:1,step:.001,value:.01,decimals:4}),epochsSlider=new ParamSlider("paramslider-epochs",{inputId:"epochs",label:"Epochs",min:1,max:100,step:1,value:20,decimals:0}),initializeInfoTabs(),initializeArchitectureControls(),initializeCharts(),attachEventListeners(),await loadDataset("structures"),buildModel(),updateNetworkDiagram()});let predictionSliders={};function updatePredictionInputs(){const container=document.getElementById("predictionInputs"),metadata=datasetMetadata[state.currentDataset];predictionSliders={};const ranges={},normParams=state.normParams[state.currentDataset];state.trainData&&state.trainData.data&&normParams&&metadata.features.forEach(feature=>{const realValues=state.trainData.data.map(row=>row[feature]).map(norm=>norm*normParams[feature].std+normParams[feature].mean);ranges[feature]={min:Math.min(...realValues),max:Math.max(...realValues)}}),container.innerHTML="";const gridContainer=document.createElement("div");gridContainer.style.display="grid",gridContainer.style.gridTemplateColumns=`repeat(${metadata.features.length}, 1fr)`,gridContainer.style.gap="15px",gridContainer.style.marginBottom="20px",container.appendChild(gridContainer),metadata.features.forEach(feature=>{const unit=metadata.units[feature]||"",range=ranges[feature];if(!range)return;const sliderDiv=document.createElement("div");sliderDiv.id=`paramslider-predict-${feature}`,gridContainer.appendChild(sliderDiv);const rangeSize=range.max-range.min;let step,decimals;rangeSize>100?(step=1,decimals=0):rangeSize>10?(step=.1,decimals=1):(step=.01,decimals=2);const defaultValue=(range.min+range.max)/2,unitLabel=unit?` (${unit})`:"";predictionSliders[feature]=new ParamSlider(`paramslider-predict-${feature}`,{inputId:`predict-${feature}`,label:`${feature}${unitLabel}`,min:range.min,max:range.max,step:step,value:defaultValue,decimals:decimals,onChange:()=>{makePrediction()}})})}async function makePrediction(){if(!state.model)return;const metadata=datasetMetadata[state.currentDataset],normParams=state.normParams[state.currentDataset],features=[];for(const feature of metadata.features){const slider=predictionSliders[feature];if(!slider)return void console.error(`Slider not found for feature: ${feature}`);const normalized=(slider.getValue()-normParams[feature].mean)/normParams[feature].std;features.push(normalized)}const xs=tf.tensor2d([features]),nn_pred_tensor=state.model.predict(xs),nn_pred_normalized=(await nn_pred_tensor.data())[0];xs.dispose(),nn_pred_tensor.dispose();const targetParam=normParams[metadata.target],nn_pred=nn_pred_normalized*targetParam.std+targetParam.mean;let lr_pred=0;if(state.linearModel){lr_pred=predictLinearRegression(state.linearModel,features)*targetParam.std+targetParam.mean}else if(state.linearModel=trainLinearRegression(),null===state.linearModel)alert("Linear regression failed: singular matrix. Showing only neural network prediction.");else{lr_pred=predictLinearRegression(state.linearModel,features)*targetParam.std+targetParam.mean}const targetUnit=metadata.units[metadata.target]||"";document.getElementById("nnPrediction").textContent=`${nn_pred.toFixed(2)} ${targetUnit}`,document.getElementById("lrPrediction").textContent=`${lr_pred.toFixed(2)} ${targetUnit}`;const warningDiv=document.getElementById("predictionWarning");0===state.currentEpoch?(warningDiv.innerHTML="⚠️ Neural network has not been trained. Predictions based on random initial weights.",warningDiv.classList.remove("hidden")):warningDiv.classList.add("hidden")}function useSampleData(){if(!state.trainData)return;const metadata=datasetMetadata[state.currentDataset],normParams=state.normParams[state.currentDataset],sample=state.trainData.data[Math.floor(Math.random()*state.trainData.data.length)];metadata.features.forEach((feature,index)=>{const realValue=sample[feature]*normParams[feature].std+normParams[feature].mean,slider=predictionSliders[feature];if(slider){const isLast=index===metadata.features.length-1;slider.setValue(realValue,{silent:!isLast})}})}function updateNetworkDiagram(){const canvas=document.getElementById("networkCanvas"),ctx=canvas.getContext("2d"),dpr=window.devicePixelRatio||1,computedStyle=window.getComputedStyle(canvas),width=parseInt(computedStyle.width),height=parseInt(computedStyle.height);if(canvas.width=width*dpr,canvas.height=height*dpr,ctx.scale(dpr,dpr),ctx.clearRect(0,0,width,height),!state.model)return;const layers=[datasetMetadata[state.currentDataset].features.length,...state.hiddenLayers.map(l=>l.units),1],layerSpacing=width/(layers.length+1),nodePositions=[];layers.forEach((layerSize,layerIdx)=>{const layerNodes=[],verticalSpacing=height/(layerSize+1);for(let i=0;i<layerSize;i++){const x=layerSpacing*(layerIdx+1),y=verticalSpacing*(i+1);layerNodes.push({x:x,y:y})}nodePositions.push(layerNodes)});const weights=getModelWeights();for(let layerIdx=0;layerIdx<layers.length-1;layerIdx++){const fromLayer=nodePositions[layerIdx],toLayer=nodePositions[layerIdx+1];if(weights[layerIdx]){const layerWeights=weights[layerIdx].weights;fromLayer.forEach((fromNode,fromIdx)=>{toLayer.forEach((toNode,toIdx)=>{const weight=layerWeights[fromIdx][toIdx],absWeight=Math.abs(weight),isHovered=state.hoveredEdge&&state.hoveredEdge.layerIdx===layerIdx&&state.hoveredEdge.fromIdx===fromIdx&&state.hoveredEdge.toIdx===toIdx,baseThickness=.5+Math.min(2*absWeight,3);ctx.lineWidth=isHovered?1.8*baseThickness:baseThickness;const baseOpacity=.3+Math.min(.7*absWeight,.7),opacity=isHovered?Math.min(1.3*baseOpacity,1):baseOpacity;ctx.strokeStyle=weight>=0?`rgba(33, 150, 243, ${opacity})`:`rgba(244, 67, 54, ${opacity})`,ctx.beginPath(),ctx.moveTo(fromNode.x,fromNode.y),ctx.lineTo(toNode.x,toNode.y),ctx.stroke()})})}}nodePositions.forEach((layerNodes,layerIdx)=>{layerNodes.forEach((node,nodeIdx)=>{const isHovered=state.hoveredNode&&state.hoveredNode.layerIdx===layerIdx&&state.hoveredNode.nodeIdx===nodeIdx;let color;color=0===layerIdx?"#1976d2":layerIdx===layers.length-1?"#388e3c":"#7b1fa2";const radius=isHovered&&layerIdx>0?19.5:15,strokeWidth=isHovered&&layerIdx>0?3:2;ctx.fillStyle=color,ctx.beginPath(),ctx.arc(node.x,node.y,radius,0,2*Math.PI),ctx.fill(),ctx.strokeStyle="white",ctx.lineWidth=strokeWidth,ctx.stroke()})}),canvas.nodePositions=nodePositions,canvas.weights=weights,canvas.nodeRadius=15}function distanceToLineSegment(px,py,x1,y1,x2,y2){const dx=x2-x1,dy=y2-y1,lengthSquared=dx*dx+dy*dy;if(0===lengthSquared)return Math.sqrt((px-x1)**2+(py-y1)**2);let t=((px-x1)*dx+(py-y1)*dy)/lengthSquared;t=Math.max(0,Math.min(1,t));const projX=x1+t*dx,projY=y1+t*dy;return Math.sqrt((px-projX)**2+(py-projY)**2)}function initializeCharts(){const ctx=document.getElementById("lossChart").getContext("2d");state.lossChart=new Chart(ctx,{type:"line",data:{labels:[],datasets:[{label:"Training Loss",data:[],borderColor:"#1976d2",backgroundColor:"rgba(25, 118, 210, 0.1)",tension:.1}]},options:{responsive:!0,maintainAspectRatio:!1,scales:{x:{title:{display:!0,text:"Epoch"}},y:{title:{display:!0,text:"Loss (MSE)"},beginAtZero:!0}},plugins:{legend:{display:!0},tooltip:{enabled:!0}}}})}function updateLossChart(){if(!state.lossChart)return;const metadata=datasetMetadata[state.currentDataset];state.lossChart.data.labels=state.trainingHistory.map((_,idx)=>idx+1),state.lossChart.data.datasets[0].data=state.trainingHistory,state.lossChart.data.datasets[0].label=`Training Loss (${metadata.name})`,state.lossChart.update()}function attachEventListeners(){document.getElementById("datasetSelect").addEventListener("change",async e=>{await loadDataset(e.target.value)}),document.getElementById("addLayerBtn").addEventListener("click",()=>{state.hiddenLayers.length<3&&(state.hiddenLayers.push({units:4,activation:"relu"}),updateLayerControls(),updateLayerCount(),resetTraining())}),document.getElementById("removeLayerBtn").addEventListener("click",()=>{state.hiddenLayers.length>1&&(state.hiddenLayers.pop(),updateLayerControls(),updateLayerCount(),resetTraining())}),document.getElementById("trainBtn").addEventListener("click",trainEpochs),document.getElementById("resetBtn").addEventListener("click",resetTraining),document.getElementById("clearHistoryBtn").addEventListener("click",clearHistory),document.getElementById("evaluateBtn").addEventListener("click",evaluateModels),document.getElementById("predictBtn").addEventListener("click",makePrediction),document.getElementById("useSampleBtn").addEventListener("click",useSampleData)}document.addEventListener("DOMContentLoaded",()=>{const canvas=document.getElementById("networkCanvas"),tooltip=document.createElement("div");tooltip.className="weight-tooltip hidden",document.body.appendChild(tooltip),canvas.addEventListener("mousemove",e=>{if(!canvas.nodePositions||!canvas.weights)return;const rect=canvas.getBoundingClientRect(),x=e.clientX-rect.left,y=e.clientY-rect.top;let foundNode=null,foundEdge=null;for(let layerIdx=0;layerIdx<canvas.nodePositions.length;layerIdx++){const layer=canvas.nodePositions[layerIdx];for(let nodeIdx=0;nodeIdx<layer.length;nodeIdx++){const node=layer[nodeIdx];if(Math.sqrt((x-node.x)**2+(y-node.y)**2)<=canvas.nodeRadius){foundNode={layerIdx:layerIdx,nodeIdx:nodeIdx};break}}if(foundNode)break}if(!foundNode)for(let layerIdx=0;layerIdx<canvas.nodePositions.length-1;layerIdx++){const fromLayer=canvas.nodePositions[layerIdx],toLayer=canvas.nodePositions[layerIdx+1];if(canvas.weights[layerIdx]){const layerWeights=canvas.weights[layerIdx].weights;for(let fromIdx=0;fromIdx<fromLayer.length;fromIdx++){for(let toIdx=0;toIdx<toLayer.length;toIdx++){const fromNode=fromLayer[fromIdx],toNode=toLayer[toIdx];if(distanceToLineSegment(x,y,fromNode.x,fromNode.y,toNode.x,toNode.y)<5){foundEdge={layerIdx:layerIdx,fromIdx:fromIdx,toIdx:toIdx,weight:layerWeights[fromIdx][toIdx]};break}}if(foundEdge)break}}if(foundEdge)break}if(foundNode){const layerIdx=foundNode.layerIdx,nodeIdx=foundNode.nodeIdx;if(layerIdx>0&&canvas.weights[layerIdx-1]){const bias=canvas.weights[layerIdx-1].biases[nodeIdx];let nodeLabel;nodeLabel=layerIdx===canvas.nodePositions.length-1?"Output":`Unit ${nodeIdx}`,tooltip.textContent=`${nodeLabel} Bias: ${bias.toFixed(4)}`,tooltip.style.left=e.clientX+10+"px",tooltip.style.top=e.clientY+10+"px",tooltip.classList.remove("hidden")}else tooltip.classList.add("hidden");(!state.hoveredNode||state.hoveredNode.layerIdx!==layerIdx||state.hoveredNode.nodeIdx!==nodeIdx)&&(state.hoveredNode={layerIdx:layerIdx,nodeIdx:nodeIdx},updateNetworkDiagram()),state.hoveredEdge&&(state.hoveredEdge=null)}else if(foundEdge){let fromLabel,toLabel;fromLabel=0===foundEdge.layerIdx?`Feature ${foundEdge.fromIdx}`:`Unit ${foundEdge.fromIdx}`,toLabel=foundEdge.layerIdx===canvas.nodePositions.length-2?"Output":`Unit ${foundEdge.toIdx}`,tooltip.textContent=`${fromLabel} → ${toLabel}: ${foundEdge.weight.toFixed(4)}`,tooltip.style.left=e.clientX+10+"px",tooltip.style.top=e.clientY+10+"px",tooltip.classList.remove("hidden");(!state.hoveredEdge||state.hoveredEdge.layerIdx!==foundEdge.layerIdx||state.hoveredEdge.fromIdx!==foundEdge.fromIdx||state.hoveredEdge.toIdx!==foundEdge.toIdx)&&(state.hoveredEdge={layerIdx:foundEdge.layerIdx,fromIdx:foundEdge.fromIdx,toIdx:foundEdge.toIdx},updateNetworkDiagram()),state.hoveredNode&&(state.hoveredNode=null)}else{tooltip.classList.add("hidden");const hadHover=state.hoveredEdge||state.hoveredNode;state.hoveredEdge&&(state.hoveredEdge=null),state.hoveredNode&&(state.hoveredNode=null),hadHover&&updateNetworkDiagram()}}),canvas.addEventListener("mouseleave",()=>{tooltip.classList.add("hidden");const hadHover=state.hoveredEdge||state.hoveredNode;state.hoveredEdge&&(state.hoveredEdge=null),state.hoveredNode&&(state.hoveredNode=null),hadHover&&updateNetworkDiagram()})});