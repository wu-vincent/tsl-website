class MultiLinearRegressionDemo{constructor(){this.featureBoxes=document.querySelectorAll(".selectorbox"),this.maeDisplay=new MetricLabel("mae","MAE",{theme:"green",label:"Mean Absolute Error",decimals:3}),this.mseDisplay=new MetricLabel("mse","MSE",{theme:"purple",label:"Mean Squared Error",decimals:3}),this.r2Display=document.getElementById("r2"),this.trainData=[],this.testData=[],this.model=null,this.features=["area","bedrooms","bathrooms","stories"],this.priceStats={mean:0,std:1},this.chart=null,this.loadData(),this.setupEventListeners(),this.initializeChart(),this.infotab=new InfoTab({onTabChange:tabId=>{window.MathJax&&window.MathJax.typesetPromise&&MathJax.typesetPromise().catch(err=>console.log("MathJax error:",err))}})}initializeChart(){const ctx=document.getElementById("prediction-plot").getContext("2d");this.chart=new Chart(ctx,{type:"scatter",data:{datasets:[{label:"Predictions vs Actual",data:[],backgroundColor:"#3498db",borderColor:"#3498db",pointRadius:4,pointHoverRadius:6},{label:"Perfect Prediction",data:[],type:"line",borderColor:"#e74c3c",borderWidth:2,borderDash:[5,5],pointRadius:0,pointHoverRadius:0,fill:!1}]},options:{responsive:!0,maintainAspectRatio:!0,aspectRatio:1.3,plugins:{legend:{display:!0,position:"top"},tooltip:{callbacks:{label:function(context){return 0===context.datasetIndex?`Actual: ${(context.parsed.x/1e3).toFixed(0)}k, Predicted: ${(context.parsed.y/1e3).toFixed(0)}k`:context.dataset.label}}}},scales:{x:{type:"linear",position:"bottom",min:0,max:6e6,title:{display:!0,text:"Actual Prices ($1000s)",font:{size:14,weight:"bold"}},ticks:{callback:function(value){return(value/1e3).toLocaleString()}},grid:{display:!0,color:"#f0f0f0"}},y:{type:"linear",min:0,max:6e6,title:{display:!0,text:"Predicted Prices ($1000s)",font:{size:14,weight:"bold"}},ticks:{callback:function(value){return(value/1e3).toLocaleString()}},grid:{display:!0,color:"#f0f0f0"}}},interaction:{intersect:!1,mode:"point"}}})}async loadData(){try{const[trainData,testData]=await Promise.all([DataManager.loadFull("data/train.csv"),DataManager.loadFull("data/test.csv")]);this.trainData=trainData,this.testData=testData,console.log(`Loaded ${this.trainData.length} training samples and ${this.testData.length} test samples`),this.priceStats=DataManager.columnStats(this.trainData,"price"),this.onFeatureSelectionChange()}catch(error){console.error("Error loading data:",error)}}normalizePrice(price){return this.priceStats.std>0?(price-this.priceStats.mean)/this.priceStats.std:0}denormalizePrice(normalizedPrice){return normalizedPrice*this.priceStats.std+this.priceStats.mean}setupEventListeners(){this.featureBoxes.forEach(box=>{box.addEventListener("click",()=>{box.classList.toggle("active"),this.onFeatureSelectionChange()})})}onFeatureSelectionChange(){this.getSelectedFeatures().length>0?this.trainModel():this.resetModel()}getSelectedFeatures(){const selected=[];return this.featureBoxes.forEach(box=>{box.classList.contains("active")&&selected.push(box.dataset.feature)}),selected}prepareFeatureMatrix(data,selectedFeatures){const n=data.length,p=selectedFeatures.length+1,X=Array(n).fill(null).map(()=>Array(p).fill(0));for(let i=0;i<n;i++)X[i][0]=1,selectedFeatures.forEach((feature,j)=>{X[i][j+1]=data[i][feature]});return X}trainModel(){const selectedFeatures=this.getSelectedFeatures();if(0===selectedFeatures.length)return;const X=this.prepareFeatureMatrix(this.trainData,selectedFeatures),y=this.trainData.map(row=>this.normalizePrice(row.price));try{const XtX=this.matrixMultiply(this.matrixTranspose(X),X),XtXinv=this.matrixInverse(XtX),Xty=this.matrixVectorMultiply(this.matrixTranspose(X),y),theta=this.matrixVectorMultiply(XtXinv,Xty);this.model={theta:theta,selectedFeatures:selectedFeatures},this.evaluateModel(),this.updateDisplay(),this.updateChart()}catch(error){console.error("Error training model:",error),alert("Error training model. Try selecting different features or normalization settings.")}}evaluateModel(){if(!this.model)return;const X_test=this.prepareFeatureMatrix(this.testData,this.model.selectedFeatures),y_test_normalized=this.testData.map(row=>this.normalizePrice(row.price)),predictions_normalized=X_test.map(row=>this.model.theta.reduce((sum,coef,i)=>sum+coef*row[i],0)),y_test=this.testData.map(row=>row.price),predictions=predictions_normalized.map(pred=>this.denormalizePrice(pred)),n=y_test_normalized.length,mse=y_test_normalized.reduce((sum,actual,i)=>sum+Math.pow(actual-predictions_normalized[i],2),0)/n,mae=y_test_normalized.reduce((sum,actual,i)=>sum+Math.abs(actual-predictions_normalized[i]),0)/n,y_mean=y_test_normalized.reduce((sum,val)=>sum+val,0)/n,ss_tot=y_test_normalized.reduce((sum,val)=>sum+Math.pow(val-y_mean,2),0),r2=1-y_test_normalized.reduce((sum,actual,i)=>sum+Math.pow(actual-predictions_normalized[i],2),0)/ss_tot;this.model.metrics={mse:mse,mae:mae,r2:r2},this.model.predictions=predictions,this.model.actual=y_test}resetModel(){this.model=null,this.updateDisplay(),this.clearChart()}updateDisplay(){if(this.model){const mse=this.model.metrics.mse,mae=this.model.metrics.mae,r2=this.model.metrics.r2;this.maeDisplay.update(mae),this.mseDisplay.update(mse),this.r2Display.innerHTML=`\\(R^2 = ${r2.toFixed(3)}\\)<div class="equation-label">Coefficient of Determination</div>`,this.r2Display.className="metriclabel",r2<.3?this.r2Display.classList.add("r2-poor"):r2<.7?this.r2Display.classList.add("r2-moderate"):this.r2Display.classList.add("r2-good"),window.MathJax&&window.MathJax.typesetPromise&&MathJax.typesetPromise([this.r2Display]).catch(err=>console.log(err))}else this.maeDisplay.update(null),this.mseDisplay.update(null),this.r2Display.innerHTML='\\(R^2 = ?\\)<div class="equation-label">Coefficient of Determination</div>',this.r2Display.className="metriclabel",window.MathJax&&window.MathJax.typesetPromise&&MathJax.typesetPromise([this.r2Display]).catch(err=>console.log(err))}updateChart(){if(!this.model||!this.chart)return;const actual=this.model.actual,predictions=this.model.predictions,scatterData=actual.map((actualVal,i)=>({x:actualVal,y:predictions[i]})),{xScale:xScale,yScale:yScale}=DataManager.normalize(scatterData),minVal=Math.min(xScale.min,yScale.min),maxVal=Math.max(xScale.max,yScale.max),padding=.1*(maxVal-minVal||Math.max(Math.abs(minVal),1)),lineMin=minVal-padding,lineMax=maxVal+padding,lineData=[{x:lineMin,y:lineMin},{x:lineMax,y:lineMax}];this.chart.data.datasets[0].data=scatterData,this.chart.data.datasets[1].data=lineData,this.chart.options.scales.x.min=lineMin,this.chart.options.scales.x.max=lineMax,this.chart.options.scales.y.min=lineMin,this.chart.options.scales.y.max=lineMax,this.chart.update()}clearChart(){this.chart&&(this.chart.data.datasets[0].data=[],this.chart.data.datasets[1].data=[],this.chart.update())}matrixMultiply(A,B){const result=Array(A.length).fill(null).map(()=>Array(B[0].length).fill(0));for(let i=0;i<A.length;i++)for(let j=0;j<B[0].length;j++)for(let k=0;k<B.length;k++)result[i][j]+=A[i][k]*B[k][j];return result}matrixTranspose(A){return A[0].map((_,i)=>A.map(row=>row[i]))}matrixVectorMultiply(A,v){return A.map(row=>row.reduce((sum,val,i)=>sum+val*v[i],0))}matrixInverse(A){const n=A.length,augmented=A.map((row,i)=>[...row,...Array(n).fill(0).map((_,j)=>i===j?1:0)]);for(let i=0;i<n;i++){let maxRow=i;for(let k=i+1;k<n;k++)Math.abs(augmented[k][i])>Math.abs(augmented[maxRow][i])&&(maxRow=k);[augmented[i],augmented[maxRow]]=[augmented[maxRow],augmented[i]];const pivot=augmented[i][i];if(Math.abs(pivot)<1e-10)throw new Error("Matrix is singular");for(let j=0;j<2*n;j++)augmented[i][j]/=pivot;for(let k=0;k<n;k++)if(k!==i){const factor=augmented[k][i];for(let j=0;j<2*n;j++)augmented[k][j]-=factor*augmented[i][j]}}return augmented.map(row=>row.slice(n))}}