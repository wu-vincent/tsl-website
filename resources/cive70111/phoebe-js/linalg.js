!function(global){"use strict";class LinAlg{static multiply(A,B){if(LinAlg._validateMatrix(A,"A"),LinAlg._validateMatrix(B,"B"),A[0].length!==B.length)throw new Error("Matrix dimension mismatch: columns of A must match rows of B");const rows=A.length,cols=B[0].length,inner=B.length,result=Array.from({length:rows},()=>Array(cols).fill(0));for(let i=0;i<rows;i++)for(let k=0;k<inner;k++){const aVal=A[i][k];if(0!==aVal)for(let j=0;j<cols;j++)result[i][j]+=aVal*B[k][j]}return result}static vectorMultiply(A,v){if(LinAlg._validateMatrix(A,"A"),LinAlg._validateVector(v,"v"),A[0].length!==v.length)throw new Error("Matrix/vector dimension mismatch");return A.map(row=>{let sum=0;for(let i=0;i<row.length;i++)sum+=row[i]*v[i];return sum})}static transpose(matrix){LinAlg._validateMatrix(matrix,"matrix");const rows=matrix.length,cols=matrix[0].length,result=Array.from({length:cols},()=>Array(rows).fill(0));for(let i=0;i<rows;i++)for(let j=0;j<cols;j++)result[j][i]=matrix[i][j];return result}static gaussianElimination(A,b,tolerance=1e-10){LinAlg._validateMatrix(A,"A"),LinAlg._validateVector(b,"b");const n=A.length;if(A[0].length!==n)throw new Error("Gaussian elimination requires a square matrix");if(b.length!==n)throw new Error("Vector length must match matrix dimension");const augmented=A.map((row,i)=>{const copy=row.slice();return copy.push(b[i]),copy});for(let pivot=0;pivot<n;pivot++){let maxRow=pivot,maxValue=Math.abs(augmented[pivot][pivot]);for(let row=pivot+1;row<n;row++){const value=Math.abs(augmented[row][pivot]);value>maxValue&&(maxValue=value,maxRow=row)}if(maxValue<tolerance)throw new Error("Matrix is singular or ill-conditioned");if(maxRow!==pivot){const temp=augmented[pivot];augmented[pivot]=augmented[maxRow],augmented[maxRow]=temp}const pivotValue=augmented[pivot][pivot];for(let col=pivot;col<=n;col++)augmented[pivot][col]/=pivotValue;for(let row=0;row<n;row++){if(row===pivot)continue;const factor=augmented[row][pivot];if(!(Math.abs(factor)<tolerance))for(let col=pivot;col<=n;col++)augmented[row][col]-=factor*augmented[pivot][col]}}return augmented.map(row=>row[n])}static identity(n){if(!Number.isInteger(n)||n<=0)throw new Error("Identity matrix size must be a positive integer");const matrix=Array.from({length:n},()=>Array(n).fill(0));for(let i=0;i<n;i++)matrix[i][i]=1;return matrix}static addBiasColumn(matrix){return LinAlg._validateMatrix(matrix,"matrix"),matrix.map(row=>[1,...row])}static predict(matrix,coefficients){return LinAlg.vectorMultiply(matrix,coefficients)}static _validateMatrix(matrix,name){if(!Array.isArray(matrix)||0===matrix.length)throw new Error(`${name} must be a non-empty matrix`);const cols=matrix[0].length;if(!Array.isArray(matrix[0])||0===cols)throw new Error(`${name} must have at least one column`);for(let i=0;i<matrix.length;i++){const row=matrix[i];if(!Array.isArray(row)||row.length!==cols)throw new Error(`${name} must be rectangular`);for(let j=0;j<row.length;j++)if(!Number.isFinite(row[j]))throw new Error(`${name} must contain only finite numbers`)}}static _validateVector(vector,name){if(!Array.isArray(vector)||0===vector.length)throw new Error(`${name} must be a non-empty vector`);for(let i=0;i<vector.length;i++)if(!Number.isFinite(vector[i]))throw new Error(`${name} must contain only finite numbers`)}}"undefined"!=typeof module&&module.exports?module.exports=LinAlg:(global.LinAlg=LinAlg,global.LinearAlgebra=LinAlg)}("undefined"!=typeof window?window:globalThis);