class DataManager{static parseCSV(csvText,options={}){const opts={delimiter:",",skipEmptyLines:!0,trimValues:!0,parseNumbers:!0,...options};let lines=csvText.split("\n");if(opts.skipEmptyLines&&(lines=lines.filter(line=>line.trim().length>0)),0===lines.length)return[];const headers=this._parseCSVLine(lines[0],opts.delimiter,opts.trimValues),data=[];for(let i=1;i<lines.length;i++){const values=this._parseCSVLine(lines[i],opts.delimiter,opts.trimValues),row={};headers.forEach((header,idx)=>{let value=values[idx]||"";if(opts.parseNumbers&&""!==value){const numValue=parseFloat(value);isNaN(numValue)||(value=numValue)}row[header]=value}),data.push(row)}return data}static _parseCSVLine(line,delimiter=",",trim=!0){const values=[];let currentValue="",insideQuotes=!1;for(let i=0;i<line.length;i++){const char=line[i];'"'===char?insideQuotes=!insideQuotes:char!==delimiter||insideQuotes?currentValue+=char:(values.push(trim?currentValue.trim():currentValue),currentValue="")}return values.push(trim?currentValue.trim():currentValue),values}static toCSV(data,headers=null){if(0===data.length)return"";const cols=headers||Object.keys(data[0]),lines=[cols.join(",")];for(const row of data){const values=cols.map(col=>{const value=row[col];return"string"==typeof value&&(value.includes(",")||value.includes('"'))?`"${value.replace(/"/g,'""')}"`:null!=value?value:""});lines.push(values.join(","))}return lines.join("\n")}static getCSVHeaders(csvText,delimiter=","){const lines=csvText.split("\n").filter(line=>line.trim().length>0);return 0===lines.length?[]:this._parseCSVLine(lines[0],delimiter,!0)}static extractColumns(data,columnNames){const result={};return columnNames.forEach(colName=>{result[colName]=data.map(row=>row[colName])}),result}static extractXY(data,xColumn,yColumn){return data.map(row=>({x:row[xColumn],y:row[yColumn]}))}static async loadCSV(file,xColumn,yColumn,options={}){try{const response=await fetch(file);if(!response.ok)throw new Error(`HTTP error! status: ${response.status}`);const csvText=await response.text(),data=this.parseCSV(csvText,options);if(data.length>0){if(!(xColumn in data[0]))throw new Error(`Column "${xColumn}" not found in CSV`);if(!(yColumn in data[0]))throw new Error(`Column "${yColumn}" not found in CSV`)}return data.map(row=>({x:row[xColumn],y:row[yColumn]}))}catch(error){throw console.error(`Error loading CSV file ${file}:`,error),error}}static async loadFromConfig(config,options={}){return await this.loadCSV(config.file,config.xColumn,config.yColumn,options)}static async loadColumns(file,columns,options={}){try{const response=await fetch(file);if(!response.ok)throw new Error(`HTTP error! status: ${response.status}`);const csvText=await response.text(),data=this.parseCSV(csvText,options);if(data.length>0)for(const col of columns)if(!(col in data[0]))throw new Error(`Column "${col}" not found in CSV`);return data.map(row=>{const filtered={};return columns.forEach(col=>{filtered[col]=row[col]}),filtered})}catch(error){throw console.error(`Error loading CSV file ${file}:`,error),error}}static async loadFull(file,options={}){try{const response=await fetch(file);if(!response.ok)throw new Error(`HTTP error! status: ${response.status}`);const csvText=await response.text();return this.parseCSV(csvText,options)}catch(error){throw console.error(`Error loading CSV file ${file}:`,error),error}}static async loadJSON(file){try{const response=await fetch(file);if(!response.ok)throw new Error(`HTTP error! status: ${response.status}`);return await response.json()}catch(error){throw console.error(`Error loading JSON file ${file}:`,error),error}}static async loadMultiple(datasets){const promises={};for(const[key,config]of Object.entries(datasets))promises[key]=this.loadFromConfig(config);const results={};for(const[key,promise]of Object.entries(promises))try{results[key]=await promise}catch(error){console.error(`Failed to load dataset "${key}":`,error),results[key]=null}return results}static filter(data,filterFn){return data.filter(filterFn)}static sort(data,columnName,ascending=!0){return data.slice().sort((a,b)=>{const aVal=a[columnName],bVal=b[columnName];return aVal<bVal?ascending?-1:1:aVal>bVal?ascending?1:-1:0})}static columnStats(data,columnName){const values=data.map(row=>row[columnName]).filter(v=>"number"==typeof v);if(0===values.length)return{mean:0,std:0,min:0,max:0,median:0};const sorted=values.slice().sort((a,b)=>a-b),mean=values.reduce((acc,val)=>acc+val,0)/values.length,variance=values.reduce((acc,val)=>acc+Math.pow(val-mean,2),0)/values.length,std=Math.sqrt(variance),median=sorted.length%2==0?(sorted[sorted.length/2-1]+sorted[sorted.length/2])/2:sorted[Math.floor(sorted.length/2)];return{mean:mean,std:std,min:sorted[0],max:sorted[sorted.length-1],median:median}}static calculateBounds(data,paddingPercent=10){if(0===data.length)return{xMin:0,xMax:1,yMin:0,yMax:1};const xValues=data.map(p=>p.x),yValues=data.map(p=>p.y),xMin=Math.min(...xValues),xMax=Math.max(...xValues),yMin=Math.min(...yValues),yMax=Math.max(...yValues),xPadding=paddingPercent/100*(xMax-xMin),yPadding=paddingPercent/100*(yMax-yMin);return{xMin:xMin-xPadding,xMax:xMax+xPadding,yMin:yMin-yPadding,yMax:yMax+yPadding}}static normalize(data){if(0===data.length)return{normalizedData:[],xScale:{min:0,max:1},yScale:{min:0,max:1}};const xValues=data.map(p=>p.x),yValues=data.map(p=>p.y),xMin=Math.min(...xValues),xMax=Math.max(...xValues),yMin=Math.min(...yValues),yMax=Math.max(...yValues),xRange=xMax-xMin||1,yRange=yMax-yMin||1;return{normalizedData:data.map(p=>({x:(p.x-xMin)/xRange,y:(p.y-yMin)/yRange})),xScale:{min:xMin,max:xMax,range:xRange},yScale:{min:yMin,max:yMax,range:yRange}}}static denormalize(normalizedData,xScale,yScale){return normalizedData.map(p=>({x:p.x*xScale.range+xScale.min,y:p.y*yScale.range+yScale.min}))}static standardize(data){if(0===data.length)return{standardizedData:[],xStats:{mean:0,std:1},yStats:{mean:0,std:1}};const xValues=data.map(p=>p.x),yValues=data.map(p=>p.y),xMean=xValues.reduce((a,b)=>a+b,0)/xValues.length,yMean=yValues.reduce((a,b)=>a+b,0)/yValues.length,xVariance=xValues.reduce((acc,val)=>acc+Math.pow(val-xMean,2),0)/xValues.length,yVariance=yValues.reduce((acc,val)=>acc+Math.pow(val-yMean,2),0)/yValues.length,xStd=Math.sqrt(xVariance)||1,yStd=Math.sqrt(yVariance)||1;return{standardizedData:data.map(p=>({x:(p.x-xMean)/xStd,y:(p.y-yMean)/yStd})),xStats:{mean:xMean,std:xStd},yStats:{mean:yMean,std:yStd}}}static trainTestSplit(data,trainRatio=.8,shuffle=!0){if(trainRatio<0||trainRatio>1)throw new Error("trainRatio must be between 0 and 1");let workingData=data.slice();if(shuffle)for(let i=workingData.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[workingData[i],workingData[j]]=[workingData[j],workingData[i]]}const splitIndex=Math.floor(workingData.length*trainRatio);return{train:workingData.slice(0,splitIndex),test:workingData.slice(splitIndex)}}}