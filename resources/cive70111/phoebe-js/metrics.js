class Metrics{static mse(yTrue,yPred){if(yTrue.length!==yPred.length)throw new Error("Arrays must have the same length");if(0===yTrue.length)return 0;let sumSquaredErrors=0;for(let i=0;i<yTrue.length;i++){const error=yTrue[i]-yPred[i];sumSquaredErrors+=error*error}return sumSquaredErrors/yTrue.length}static rmse(yTrue,yPred){return Math.sqrt(this.mse(yTrue,yPred))}static mae(yTrue,yPred){if(yTrue.length!==yPred.length)throw new Error("Arrays must have the same length");if(0===yTrue.length)return 0;let sumAbsErrors=0;for(let i=0;i<yTrue.length;i++)sumAbsErrors+=Math.abs(yTrue[i]-yPred[i]);return sumAbsErrors/yTrue.length}static r2(yTrue,yPred){if(yTrue.length!==yPred.length)throw new Error("Arrays must have the same length");if(0===yTrue.length)return 0;const mean=yTrue.reduce((sum,val)=>sum+val,0)/yTrue.length,ssTot=yTrue.reduce((sum,val)=>sum+Math.pow(val-mean,2),0),ssRes=yTrue.reduce((sum,val,i)=>sum+Math.pow(val-yPred[i],2),0);return 0===ssTot?1:1-ssRes/ssTot}static accuracy(yTrue,yPred){if(yTrue.length!==yPred.length)throw new Error("Arrays must have the same length");if(0===yTrue.length)return 0;let correct=0;for(let i=0;i<yTrue.length;i++)yTrue[i]===yPred[i]&&correct++;return correct/yTrue.length*100}static confusionMatrix(yTrue,yPred){if(yTrue.length!==yPred.length)throw new Error("Arrays must have the same length");let tp=0,fp=0,tn=0,fn=0;for(let i=0;i<yTrue.length;i++)1===yTrue[i]&&1===yPred[i]?tp++:0===yTrue[i]&&1===yPred[i]?fp++:0===yTrue[i]&&0===yPred[i]?tn++:1===yTrue[i]&&0===yPred[i]&&fn++;return{tp:tp,fp:fp,tn:tn,fn:fn}}static precision(yTrue,yPred){const{tp:tp,fp:fp}=this.confusionMatrix(yTrue,yPred);return tp+fp===0?0:tp/(tp+fp)}static recall(yTrue,yPred){const{tp:tp,fn:fn}=this.confusionMatrix(yTrue,yPred);return tp+fn===0?0:tp/(tp+fn)}static f1Score(yTrue,yPred){const p=this.precision(yTrue,yPred),r=this.recall(yTrue,yPred);return p+r===0?0:p*r*2/(p+r)}static logLoss(yTrue,yProbPred){if(yTrue.length!==yProbPred.length)throw new Error("Arrays must have the same length");if(0===yTrue.length)return 0;let sum=0;for(let i=0;i<yTrue.length;i++){const prob=Math.max(1e-15,Math.min(1-1e-15,yProbPred[i]));1===yTrue[i]?sum+=Math.log(prob):sum+=Math.log(1-prob)}return-sum/yTrue.length}static mpe(yTrue,yPred){if(yTrue.length!==yPred.length)throw new Error("Arrays must have the same length");if(0===yTrue.length)return 0;let sumPercentErrors=0;for(let i=0;i<yTrue.length;i++)0!==yTrue[i]&&(sumPercentErrors+=(yTrue[i]-yPred[i])/yTrue[i]*100);return sumPercentErrors/yTrue.length}static mape(yTrue,yPred){if(yTrue.length!==yPred.length)throw new Error("Arrays must have the same length");if(0===yTrue.length)return 0;let sumAbsPercentErrors=0,count=0;for(let i=0;i<yTrue.length;i++)0!==yTrue[i]&&(sumAbsPercentErrors+=100*Math.abs((yTrue[i]-yPred[i])/yTrue[i]),count++);return count>0?sumAbsPercentErrors/count:0}}