function seededRandom(seed){let state=seed;return function(){state|=0,state=state+1831565813|0;let t=Math.imul(state^state>>>15,1|state);return t=t+Math.imul(t^t>>>7,61|t)^t,((t^t>>>14)>>>0)/4294967296}}function createStandardNormalGenerator(rng){let spare=null;return function(){if(null!==spare){const value=spare;return spare=null,value}let u=0,v=0;for(;0===u;)u=rng();for(;0===v;)v=rng();const mag=Math.sqrt(-2*Math.log(u)),z0=mag*Math.cos(2*Math.PI*v),z1=mag*Math.sin(2*Math.PI*v);return spare=z1,z0}}function dotProduct(vector,weights){let total=0;for(let i=0;i<vector.length;i+=1)total+=vector[i]*weights[i];return total}function standardiseMatrix(matrix){const rows=matrix.length,cols=rows>0?matrix[0].length:0,means=Array(cols).fill(0),variances=Array(cols).fill(0);for(let i=0;i<rows;i+=1)for(let j=0;j<cols;j+=1)means[j]+=matrix[i][j];for(let j=0;j<cols;j+=1)means[j]/=rows;for(let i=0;i<rows;i+=1)for(let j=0;j<cols;j+=1){const diff=matrix[i][j]-means[j];variances[j]+=diff*diff}for(let j=0;j<cols;j+=1)variances[j]=Math.sqrt(variances[j]/rows)||1;return matrix.map(row=>row.map((value,j)=>(value-means[j])/variances[j]))}function standardiseVector(values){const n=values.length;if(0===n)return[];let mean=0;for(let i=0;i<n;i+=1)mean+=values[i];mean/=n;let variance=0;for(let i=0;i<n;i+=1){const diff=values[i]-mean;variance+=diff*diff}const std=Math.sqrt(variance/n)||1;return values.map(value=>(value-mean)/std)}function normaliseRegType(regType){return"string"!=typeof regType?"l2":regType.toLowerCase()}function generateSyntheticData(seed=12021){const normal=createStandardNormalGenerator(seededRandom(seed)),z1Array=Array.from({length:100},()=>normal()),z2Array=Array.from({length:100},()=>normal()),X=standardiseMatrix(Array.from({length:100},(_,i)=>[z1Array[i],1.4*z1Array[i]+1.4*z2Array[i]])),trueBeta=[.5,2],y=Array.from({length:100},(_,i)=>dotProduct(X[i],trueBeta)+.1*normal());return{X:X,y:y,trueBeta:trueBeta}}function computeMSELoss(X,y,beta){const n=X.length;if(0===n)return 0;let sumSquaredError=0;for(let i=0;i<n;i+=1){const prediction=dotProduct(X[i],beta),residual=y[i]-prediction;sumSquaredError+=residual*residual}return sumSquaredError/n}function computeTotalLoss(X,y,beta,lambda,regType){const mse=computeMSELoss(X,y,beta),type=normaliseRegType(regType);let penalty=0;return"l1"===type?penalty=lambda*beta.reduce((acc,value)=>acc+Math.abs(value),0):"l2"===type&&(penalty=lambda*beta.reduce((acc,value)=>acc+value*value,0)),mse+penalty}function computeMSEGradient(X,y,beta){const n=X.length;if(0===n)return[0,0];const grads=[0,0];for(let i=0;i<n;i+=1){const residual=dotProduct(X[i],beta)-y[i];grads[0]+=residual*X[i][0],grads[1]+=residual*X[i][1]}const scale=2/n;return grads[0]*=scale,grads[1]*=scale,grads}function computeGradient(X,y,beta,lambda,regType){const grads=computeMSEGradient(X,y,beta),type=normaliseRegType(regType);return"l2"===type?(grads[0]+=2*lambda*beta[0],grads[1]+=2*lambda*beta[1]):"l1"===type&&(grads[0]+=lambda*Math.sign(beta[0]),grads[1]+=lambda*Math.sign(beta[1])),grads}function gradientDescentStep(beta,gradient,learningRate){return beta.map((value,index)=>value-learningRate*gradient[index])}function proximalGradientStep(X,y,beta,lambda,learningRate){const mseGradient=computeMSEGradient(X,y,beta),betaTemp=beta.map((value,index)=>value-learningRate*mseGradient[index]),threshold=learningRate*lambda;return betaTemp.map(value=>value>threshold?value-threshold:value<-threshold?value+threshold:0)}class CanvasRenderer{constructor(canvasId){const canvas=document.getElementById(canvasId);if(!canvas)throw new Error(`CanvasRenderer: unable to find canvas with id "${canvasId}"`);this.canvas=canvas,this.ctx=canvas.getContext("2d"),this.dpr=window.devicePixelRatio||1,this.cssWidth=600,this.cssHeight=400,this.canvas.width=Math.round(this.cssWidth*this.dpr),this.canvas.height=Math.round(this.cssHeight*this.dpr),this.ctx.scale(this.dpr,this.dpr),this.padding=48,this.betaRange={minBeta1:-1,maxBeta1:1,minBeta2:-1,maxBeta2:1},this.updateScales()}updateScales(){const spanX=this.betaRange.maxBeta1-this.betaRange.minBeta1||1,spanY=this.betaRange.maxBeta2-this.betaRange.minBeta2||1;this.scaleX=(this.cssWidth-2*this.padding)/spanX,this.scaleY=(this.cssHeight-2*this.padding)/spanY}normalizeBetaRange(range){if(!range)return{...this.betaRange};if(Array.isArray(range.beta1)&&Array.isArray(range.beta2)){const[minBeta1,maxBeta1]=range.beta1,[minBeta2,maxBeta2]=range.beta2;return{minBeta1:minBeta1,maxBeta1:maxBeta1,minBeta2:minBeta2,maxBeta2:maxBeta2}}return{minBeta1:range.minBeta1,maxBeta1:range.maxBeta1,minBeta2:range.minBeta2,maxBeta2:range.maxBeta2}}setBetaRange(range){this.betaRange=this.normalizeBetaRange(range),this.updateScales()}betaToCanvas(beta){const[beta1,beta2]=beta;return{x:this.padding+(beta1-this.betaRange.minBeta1)*this.scaleX,y:this.cssHeight-this.padding-(beta2-this.betaRange.minBeta2)*this.scaleY}}clear(){this.ctx.save(),this.ctx.setTransform(1,0,0,1,0,0),this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height),this.ctx.restore()}drawLossContours(X,y,betaRange){if(!(X&&X.length&&y&&y.length))return;this.setBetaRange(betaRange);const{hessian:hessian,betaStar:betaStar}=this.computeQuadraticModel(X,y),eigen=this.eigenDecomposition(hessian);if(!eigen||eigen.values.some(value=>value<=0))return;const levels=this.computeContourLevels(hessian,betaStar);levels.forEach((level,index)=>{const t=levels.length>1?index/(levels.length-1):0,color=this.interpolateLossColor(t);this.drawQuadraticLevel(betaStar,eigen,level,color)}),this.drawAxes()}computeQuadraticModel(X,y){const n=X.length;let sum11=0,sum12=0,sum22=0,sum1y=0,sum2y=0;for(let i=0;i<n;i+=1){const[x1,x2]=X[i],target=y[i];sum11+=x1*x1,sum12+=x1*x2,sum22+=x2*x2,sum1y+=x1*target,sum2y+=x2*target}const hessian=[[sum11/n,sum12/n],[sum12/n,sum22/n]],det=sum11*sum22-sum12*sum12;let betaStar=[0,0];if(Math.abs(det)>1e-10){const invFactor=1/det,inv12=-sum12*invFactor;betaStar=[sum22*invFactor*sum1y+inv12*sum2y,inv12*sum1y+sum11*invFactor*sum2y]}return{hessian:hessian,betaStar:betaStar}}eigenDecomposition(matrix){const[[a,b],[,c]]=matrix,trace=a+c,discriminant=trace*trace-4*(a*c-b*b);if(discriminant<0)return null;const sqrtDiscriminant=Math.sqrt(discriminant),lambda1=(trace+sqrtDiscriminant)/2,lambda2=(trace-sqrtDiscriminant)/2;let v1=[b,lambda1-a],v2=[b,lambda2-a];return Math.abs(b)<1e-8&&(v1=[1,0],v2=[0,1]),v1=this.normalizeVector(v1),v2=this.normalizeVector(v2),{values:[lambda1,lambda2],vectors:[v1,v2]}}normalizeVector(vector){const[x,y]=vector,magnitude=Math.hypot(x,y)||1;return[x/magnitude,y/magnitude]}quadraticForm(matrix,point,center){const dx=point[0]-center[0],dy=point[1]-center[1],[[a,b],[,c]]=matrix;return a*dx*dx+2*b*dx*dy+c*dy*dy}computeContourLevels(hessian,betaStar){const candidates=[[this.betaRange.minBeta1,this.betaRange.minBeta2],[this.betaRange.maxBeta1,this.betaRange.minBeta2],[this.betaRange.minBeta1,this.betaRange.maxBeta2],[this.betaRange.maxBeta1,this.betaRange.maxBeta2]];let maxValue=0;for(const candidate of candidates){const value=this.quadraticForm(hessian,candidate,betaStar);maxValue=Math.max(maxValue,value)}(maxValue<=0||!Number.isFinite(maxValue))&&(maxValue=1);const levels=[];for(let i=1;i<=6;i+=1){const t=i/6,ratio=Math.pow(t,2.5);levels.push(maxValue*ratio*.95+.01)}return levels}drawQuadraticLevel(center,eigen,level,strokeStyle){const[lambda1,lambda2]=eigen.values,[v1,v2]=eigen.vectors;if(lambda1<=0||lambda2<=0)return;const radius1=Math.sqrt(level/lambda1),radius2=Math.sqrt(level/lambda2);this.ctx.save(),this.ctx.beginPath();for(let i=0;i<=120;i+=1){const theta=i/120*Math.PI*2,offset1=radius1*Math.cos(theta),offset2=radius2*Math.sin(theta),betaPoint=[center[0]+offset1*v1[0]+offset2*v2[0],center[1]+offset1*v1[1]+offset2*v2[1]],{x:x,y:y}=this.betaToCanvas(betaPoint);0===i?this.ctx.moveTo(x,y):this.ctx.lineTo(x,y)}this.ctx.strokeStyle=strokeStyle,this.ctx.lineWidth=2,this.ctx.globalAlpha=.85,this.ctx.stroke(),this.ctx.restore()}interpolateLossColor(t){const clampT=Math.min(1,Math.max(0,t));if(clampT<.5){const local=clampT/.5;return this.interpolateColor("#4ade80","#fbbf24",local)}const local=(clampT-.5)/.5;return this.interpolateColor("#fbbf24","#ef4444",local)}interpolateColor(startColor,endColor,t){const start=this.hexToRgb(startColor),end=this.hexToRgb(endColor),mix=(channelStart,channelEnd)=>Math.round(channelStart+(channelEnd-channelStart)*t);return`rgb(${mix(start.r,end.r)}, ${mix(start.g,end.g)}, ${mix(start.b,end.b)})`}hexToRgb(hex){const clean=hex.replace("#",""),value=parseInt(clean,16);return{r:value>>16&255,g:value>>8&255,b:255&value}}drawAxes(){const ctx=this.ctx;ctx.save(),ctx.strokeStyle="#1f2937",ctx.lineWidth=1,ctx.globalAlpha=.7;const xAxisBeta=this.betaRange.minBeta2<=0&&this.betaRange.maxBeta2>=0?0:(this.betaRange.minBeta2+this.betaRange.maxBeta2)/2,yAxisBeta=this.betaRange.minBeta1<=0&&this.betaRange.maxBeta1>=0?0:(this.betaRange.minBeta1+this.betaRange.maxBeta1)/2,xAxisStart=this.betaToCanvas([this.betaRange.minBeta1,xAxisBeta]),xAxisEnd=this.betaToCanvas([this.betaRange.maxBeta1,xAxisBeta]),yAxisStart=this.betaToCanvas([yAxisBeta,this.betaRange.minBeta2]),yAxisEnd=this.betaToCanvas([yAxisBeta,this.betaRange.maxBeta2]);ctx.beginPath(),ctx.moveTo(xAxisStart.x,xAxisStart.y),ctx.lineTo(xAxisEnd.x,xAxisEnd.y),ctx.moveTo(yAxisStart.x,yAxisStart.y),ctx.lineTo(yAxisEnd.x,yAxisEnd.y),ctx.stroke(),this.drawAxisTicks(xAxisBeta,yAxisBeta),this.drawAxisLabels(xAxisEnd,yAxisEnd),ctx.restore()}drawAxisTicks(xAxisBeta,yAxisBeta){const ctx=this.ctx;for(let i=0;i<=4;i+=1){const ratio=i/4,beta1=this.betaRange.minBeta1+ratio*(this.betaRange.maxBeta1-this.betaRange.minBeta1),{x:x,y:y}=this.betaToCanvas([beta1,xAxisBeta]);ctx.beginPath(),ctx.moveTo(x,y-3),ctx.lineTo(x,y+3),ctx.stroke()}for(let i=0;i<=4;i+=1){const ratio=i/4,beta2=this.betaRange.minBeta2+ratio*(this.betaRange.maxBeta2-this.betaRange.minBeta2),{x:x,y:y}=this.betaToCanvas([yAxisBeta,beta2]);ctx.beginPath(),ctx.moveTo(x-3,y),ctx.lineTo(x+3,y),ctx.stroke()}}drawAxisLabels(xAxisEnd,yAxisEnd){const ctx=this.ctx;ctx.save(),ctx.globalAlpha=1,ctx.fillStyle="#1f2937",ctx.font="14px sans-serif",ctx.fillText("β₁",xAxisEnd.x-16,xAxisEnd.y-8),ctx.fillText("β₂",yAxisEnd.x+8,yAxisEnd.y+16),ctx.restore()}drawL2RegularizationContours(lambdaValues=[]){if(!lambdaValues.length)return;const maxLambda=Math.max(...lambdaValues.map(value=>Math.abs(value)))||1,baseRadius=.45*Math.min(this.betaRange.maxBeta1-this.betaRange.minBeta1,this.betaRange.maxBeta2-this.betaRange.minBeta2);this.ctx.save(),this.ctx.strokeStyle="#9ca3af",this.ctx.lineWidth=1.5,this.ctx.globalAlpha=.4,lambdaValues.slice().sort((a,b)=>Math.abs(a)-Math.abs(b)).forEach(lambda=>{const radiusBeta=baseRadius*(Math.abs(lambda)/maxLambda),points=[];for(let i=0;i<=96;i+=1){const theta=i/96*Math.PI*2,betaPoint=[radiusBeta*Math.cos(theta),radiusBeta*Math.sin(theta)],{x:x,y:y}=this.betaToCanvas(betaPoint);points.push({x:x,y:y})}this.ctx.beginPath(),points.forEach(({x:x,y:y},index)=>{0===index?this.ctx.moveTo(x,y):this.ctx.lineTo(x,y)}),this.ctx.stroke()}),this.ctx.restore()}drawL1RegularizationContours(lambdaValues=[]){if(!lambdaValues.length)return;const maxLambda=Math.max(...lambdaValues.map(value=>Math.abs(value)))||1,baseRadius=.45*Math.min(this.betaRange.maxBeta1-this.betaRange.minBeta1,this.betaRange.maxBeta2-this.betaRange.minBeta2);this.ctx.save(),this.ctx.strokeStyle="#9ca3af",this.ctx.lineWidth=1.5,this.ctx.globalAlpha=.35,lambdaValues.slice().sort((a,b)=>Math.abs(a)-Math.abs(b)).forEach(lambda=>{const radiusBeta=baseRadius*(Math.abs(lambda)/maxLambda),vertices=[this.betaToCanvas([0,radiusBeta]),this.betaToCanvas([radiusBeta,0]),this.betaToCanvas([0,-radiusBeta]),this.betaToCanvas([-radiusBeta,0])];this.ctx.beginPath(),vertices.forEach(({x:x,y:y},index)=>{0===index?this.ctx.moveTo(x,y):this.ctx.lineTo(x,y)}),this.ctx.closePath(),this.ctx.stroke()}),this.ctx.restore()}drawTrajectoryPoint(beta,isStart=!1,isEnd=!1){const{x:x,y:y}=this.betaToCanvas(beta),radius=isStart||isEnd?6:3;let fillStyle="#9b59b6";isStart?fillStyle="#3b82f6":isEnd&&(fillStyle="#ef4444"),this.ctx.save(),this.ctx.beginPath(),this.ctx.arc(x,y,radius,0,2*Math.PI),this.ctx.fillStyle=fillStyle,this.ctx.globalAlpha=.9,this.ctx.fill(),this.ctx.restore()}drawOptimalPoint(beta){const{x:x,y:y}=this.betaToCanvas(beta);this.ctx.save(),this.ctx.beginPath(),this.ctx.arc(x,y,6,0,2*Math.PI),this.ctx.fillStyle="#9ca3af",this.ctx.globalAlpha=.4,this.ctx.fill(),this.ctx.restore()}drawArrow(fromBeta,toBeta){const from=this.betaToCanvas(fromBeta),to=this.betaToCanvas(toBeta),dx=to.x-from.x,dy=to.y-from.y,length=Math.hypot(dx,dy)||1,unitX=dx/length,unitY=dy/length;this.ctx.save(),this.ctx.strokeStyle="#9b59b6",this.ctx.fillStyle="#9b59b6",this.ctx.lineWidth=2,this.ctx.beginPath(),this.ctx.moveTo(from.x,from.y),this.ctx.lineTo(to.x,to.y),this.ctx.stroke(),this.ctx.beginPath(),this.ctx.moveTo(to.x,to.y),this.ctx.lineTo(to.x-12*unitX+6*unitY,to.y-12*unitY-6*unitX),this.ctx.lineTo(to.x-12*unitX-6*unitY,to.y-12*unitY+6*unitX),this.ctx.closePath(),this.ctx.fill(),this.ctx.restore()}}let data=null,l2Renderer=null,l1Renderer=null,isAnimating=!1,animationHandle=null,currentTab=null,l2LambdaSlider=null,l1LambdaSlider=null,l2ParamsDisplay=null,l1ParamsDisplay=null;const MAX_ITERATIONS=100,CONVERGENCE_THRESHOLD=.01,ANIMATION_DELAY=100;function computeLearningRate(lambda){return.2/(1+lambda/2)}const BETA_RANGE={beta1:[-3,4],beta2:[-2,4]},INITIAL_BETA=[-2,2];function init(){data=generateSyntheticData(12021);try{l2Renderer=new CanvasRenderer("l2-plot"),l1Renderer=new CanvasRenderer("l1-plot"),l2Renderer.setBetaRange(BETA_RANGE),l1Renderer.setBetaRange(BETA_RANGE),drawInitialContours("l2"),drawInitialContours("l1")}catch(error){return void console.error("Failed to initialize renderers:",error)}l2ParamsDisplay=new MetricLabel("l2-params","",{background:"#f8f9fa",color:"#2c3e50",border:"#dee2e6",borderLeft:"#6c757d",label:"Fitted Weights",separator:":"}),l1ParamsDisplay=new MetricLabel("l1-params","",{background:"#f8f9fa",color:"#2c3e50",border:"#dee2e6",borderLeft:"#6c757d",label:"Fitted Weights",separator:":"}),setupEventHandlers(),updateDisplays("l2",INITIAL_BETA,0),updateDisplays("l1",INITIAL_BETA,0)}function drawInitialContours(tabType){const renderer="l2"===tabType?l2Renderer:l1Renderer;renderer.clear(),renderer.drawLossContours(data.X,data.y,BETA_RANGE);const lambdaLevels=[10,30,60,90];"l2"===tabType?renderer.drawL2RegularizationContours(lambdaLevels):renderer.drawL1RegularizationContours(lambdaLevels),renderer.drawOptimalPoint(data.trueBeta),renderer.drawTrajectoryPoint(INITIAL_BETA,!0,!1)}function setupEventHandlers(){document.querySelectorAll(".demo-tab-btn").forEach(btn=>{btn.addEventListener("click",()=>{switchDemoTab(btn.dataset.tab)})}),l2LambdaSlider=new ParamSlider("paramslider-l2-lambda",{inputId:"l2-lambda",label:"λ (L2 Regularisation)",scale:"log",min:0,max:100,value:0,decimals:null,fineTuneStep:1}),l1LambdaSlider=new ParamSlider("paramslider-l1-lambda",{inputId:"l1-lambda",label:"λ (L1 Regularisation)",scale:"log",min:0,max:100,value:0,decimals:null,fineTuneStep:1});const l2TrainLossEl=document.getElementById("l2-train-loss");l2TrainLossEl.style.background="#e3f2fd",l2TrainLossEl.style.color="#1976d2",l2TrainLossEl.style.border="1px solid #bbdefb",l2TrainLossEl.style.borderLeft="4px solid #2196f3";const l2TotalLossEl=document.getElementById("l2-total-loss");l2TotalLossEl.style.background="#f3e5f5",l2TotalLossEl.style.color="#7b1fa2",l2TotalLossEl.style.border="1px solid #e1bee7",l2TotalLossEl.style.borderLeft="4px solid #9c27b0";const l1TrainLossEl=document.getElementById("l1-train-loss");l1TrainLossEl.style.background="#e3f2fd",l1TrainLossEl.style.color="#1976d2",l1TrainLossEl.style.border="1px solid #bbdefb",l1TrainLossEl.style.borderLeft="4px solid #2196f3";const l1TotalLossEl=document.getElementById("l1-total-loss");l1TotalLossEl.style.background="#f3e5f5",l1TotalLossEl.style.color="#7b1fa2",l1TotalLossEl.style.border="1px solid #e1bee7",l1TotalLossEl.style.borderLeft="4px solid #9c27b0";const l2TrainBtn=document.getElementById("l2-train-btn"),l2StopBtn=document.getElementById("l2-stop-btn");l2TrainBtn.addEventListener("click",()=>{startTraining("l2",l2LambdaSlider.getValue())}),l2StopBtn.addEventListener("click",()=>{stopTraining("l2")});const l1TrainBtn=document.getElementById("l1-train-btn"),l1StopBtn=document.getElementById("l1-stop-btn");l1TrainBtn.addEventListener("click",()=>{startTraining("l1",l1LambdaSlider.getValue())}),l1StopBtn.addEventListener("click",()=>{stopTraining("l1")});const l2PlusBtn=document.getElementById("l2-lambda-plus"),l2MinusBtn=document.getElementById("l2-lambda-minus");l2PlusBtn.addEventListener("click",()=>{adjustLambda(l2LambdaSlider,5)}),l2MinusBtn.addEventListener("click",()=>{adjustLambda(l2LambdaSlider,.2)});const l1PlusBtn=document.getElementById("l1-lambda-plus"),l1MinusBtn=document.getElementById("l1-lambda-minus");l1PlusBtn.addEventListener("click",()=>{adjustLambda(l1LambdaSlider,5)}),l1MinusBtn.addEventListener("click",()=>{adjustLambda(l1LambdaSlider,.2)})}function adjustLambda(slider,factor){const currentValue=slider.getValue();if(0===currentValue&&factor>1)slider.setValue(1e-7);else{if(0===currentValue)return;{let newValue=currentValue*factor;newValue<1e-7&&factor<1&&(newValue=0),newValue=Math.max(0,Math.min(100,newValue)),slider.setValue(newValue)}}}function switchDemoTab(targetTab){document.querySelectorAll(".demo-tab-btn").forEach(btn=>{btn.dataset.tab===targetTab?btn.classList.add("active"):btn.classList.remove("active")});document.querySelectorAll(".demo-tab-content").forEach(content=>{content.dataset.tab===targetTab?content.classList.add("active"):content.classList.remove("active")})}function toggleButtons(tabType,training){const trainBtn=document.getElementById(`${tabType}-train-btn`),stopBtn=document.getElementById(`${tabType}-stop-btn`);training?(trainBtn.style.display="none",stopBtn.style.display="block"):(trainBtn.style.display="block",stopBtn.style.display="none")}function stopTraining(tabType){isAnimating&&(animationHandle&&(clearTimeout(animationHandle),animationHandle=null),isAnimating=!1,currentTab=null,toggleButtons(tabType,!1))}function startTraining(tabType,lambda){isAnimating&&animationHandle&&(clearTimeout(animationHandle),animationHandle=null,currentTab&&currentTab!==tabType&&toggleButtons(currentTab,!1)),isAnimating=!0,currentTab=tabType,toggleButtons(tabType,!0);const renderer="l2"===tabType?l2Renderer:l1Renderer,regType="l2"===tabType?"l2":"l1",learningRate=computeLearningRate(lambda);renderer.clear(),renderer.drawLossContours(data.X,data.y,BETA_RANGE);const lambdaLevels=[10,30,60,90];"l2"===tabType?renderer.drawL2RegularizationContours(lambdaLevels):renderer.drawL1RegularizationContours(lambdaLevels),renderer.drawOptimalPoint(data.trueBeta);let beta=[...INITIAL_BETA],iteration=0,prevBeta=null;renderer.drawTrajectoryPoint(beta,!0,!1),updateDisplays(tabType,beta,lambda);const animate=()=>{if(iteration>=100)return renderer.drawTrajectoryPoint(beta,!1,!0),isAnimating=!1,animationHandle=null,currentTab=null,void toggleButtons(tabType,!1);const gradient=computeGradient(data.X,data.y,beta,lambda,regType);if(Math.sqrt(gradient[0]**2+gradient[1]**2)<.01)return renderer.drawTrajectoryPoint(beta,!1,!0),isAnimating=!1,animationHandle=null,currentTab=null,void toggleButtons(tabType,!1);if(null!==prevBeta){if(Math.sqrt(Math.pow(beta[0]-prevBeta[0],2)+Math.pow(beta[1]-prevBeta[1],2))<1e-6)return renderer.drawTrajectoryPoint(beta,!1,!0),isAnimating=!1,animationHandle=null,currentTab=null,void toggleButtons(tabType,!1)}let newBeta;newBeta="l1"===regType?proximalGradientStep(data.X,data.y,beta,lambda,learningRate):gradientDescentStep(beta,gradient,learningRate),renderer.drawArrow(beta,newBeta),renderer.drawTrajectoryPoint(newBeta,!1,!1),updateDisplays(tabType,newBeta,lambda),prevBeta=[...beta],beta=newBeta,iteration++,animationHandle=setTimeout(animate,100)};animationHandle=setTimeout(animate,100)}function updateDisplays(tabType,beta,lambda){const paramsText=`\\beta_1 = ${beta[0].toFixed(2)}, \\beta_2 = ${beta[1].toFixed(2)}`,paramsEl=document.getElementById(`${tabType}-params`);paramsEl&&(paramsEl.innerHTML=`\\(${paramsText}\\)<div class="equation-label">Fitted Weights</div>`);const trainLoss=computeMSELoss(data.X,data.y,beta),regType="l2"===tabType?"l2":"l1",totalLoss=computeTotalLoss(data.X,data.y,beta,lambda,regType),trainLossEl=document.getElementById(`${tabType}-train-loss`),totalLossEl=document.getElementById(`${tabType}-total-loss`);trainLossEl.innerHTML=`\\(${trainLoss.toFixed(4)}\\)<div class="equation-label">Training Loss</div>`,totalLossEl.innerHTML=`\\(${totalLoss.toFixed(4)}\\)<div class="equation-label">Total Loss</div>`,window.MathJax&&window.MathJax.typesetPromise&&MathJax.typesetPromise([paramsEl,trainLossEl,totalLossEl]).catch(err=>console.log("MathJax error:",err))}"loading"===document.readyState?document.addEventListener("DOMContentLoaded",init):init();