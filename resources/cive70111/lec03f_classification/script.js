class ClassificationDemo{constructor(){this.canvas=document.getElementById("plot"),this.chart=null,this.alphaSlider=document.getElementById("alpha"),this.betaSlider=document.getElementById("beta"),this.alphaValue=document.getElementById("alpha-value"),this.betaValue=document.getElementById("beta-value"),this.equation=document.getElementById("equation"),this.classifierType="linear",this.accuracyDisplay=new MetricLabel("accuracy","Accuracy",{theme:"purple",decimals:1,unit:"%"}),this.lossDisplay=new MetricLabel("loss","Loss",{theme:"green",decimals:3}),this.solutionBtn=document.getElementById("solution-btn"),this.generateDataBtn=document.getElementById("generate-data-btn"),this.clearDataBtn=document.getElementById("clear-data-btn"),this.classifierBoxes=document.querySelectorAll(".fancybox"),this.xMin=-10,this.xMax=10,this.yMin=-.1,this.yMax=1.1,this.generateDataPoints(),this.assignSortedIDs(),this.initializeChart(),this.setupEventListeners(),this.initializeDisplay(),this.infotab=new InfoTab,this.updatePredictionsTable()}generateDataPoints(){this.dataPoints=[];const isTooClose=(newX,y,points,minDist)=>points.some(p=>p.y===y&&Math.abs(p.x-newX)<minDist),generateClusteredPoint=(center,spread)=>{const u1=Math.random(),u2=Math.random();return center+Math.sqrt(-2*Math.log(u1))*Math.cos(2*Math.PI*u2)*spread},numClusters0=Math.random()<.5?2:3,clusters0=[];for(let i=0;i<numClusters0;i++){const center=6*Math.random()-6;clusters0.push(center)}const numClusters1=Math.random()<.5?2:3,clusters1=[];for(let i=0;i<numClusters1;i++){const center=0+6*Math.random();clusters1.push(center)}const class0Points=[];let attempts=0;for(;class0Points.length<7&&attempts<200;){const clusterCenter=clusters0[Math.floor(Math.random()*clusters0.length)];let x;x=Math.random()<.85?generateClusteredPoint(clusterCenter,1.2):16*Math.random()-8,x=Math.max(-8,Math.min(8,x)),isTooClose(x,0,class0Points,.3)||class0Points.push({x:x,y:0}),attempts++}this.dataPoints.push(...class0Points);const class1Points=[];for(attempts=0;class1Points.length<8&&attempts<200;){const clusterCenter=clusters1[Math.floor(Math.random()*clusters1.length)];let x;x=Math.random()<.85?generateClusteredPoint(clusterCenter,1.2):16*Math.random()-8,x=Math.max(-8,Math.min(8,x)),isTooClose(x,1,class1Points,.3)||class1Points.push({x:x,y:1}),attempts++}this.dataPoints.push(...class1Points)}assignSortedIDs(){[...this.dataPoints].sort((a,b)=>a.x-b.x).forEach((point,index)=>{point.sortedID=index})}getConfidenceRegionsPlugin(){const demo=this;return{id:"confidenceRegions",beforeDatasetsDraw(chart){const ctx=chart.ctx,xScale=chart.scales.x,yScale=chart.scales.y,alpha=parseFloat(demo.alphaSlider.value),beta=parseFloat(demo.betaSlider.value);ctx.save();const xMin=demo.xMin,dx=(demo.xMax-xMin)/200;for(let i=0;i<200;i++){const x1=xMin+i*dx,x2=xMin+(i+1)*dx,xMid=(x1+x2)/2,prediction=demo.predict(xMid,alpha,beta,demo.classifierType),distanceFrom05=Math.abs(prediction-.5);let fillColor;fillColor=distanceFrom05>=.35?"rgba(46, 204, 113, 0.15)":distanceFrom05>=.2?"rgba(255, 193, 7, 0.15)":"rgba(231, 76, 60, 0.15)",ctx.fillStyle=fillColor;const x1Pixel=xScale.getPixelForValue(x1),x2Pixel=xScale.getPixelForValue(x2);if(prediction<.5){const yTopPixel=yScale.getPixelForValue(prediction),yBottomPixel=yScale.getPixelForValue(0);ctx.fillRect(x1Pixel,yTopPixel,x2Pixel-x1Pixel,yBottomPixel-yTopPixel)}else{const yTopPixel=yScale.getPixelForValue(1),yBottomPixel=yScale.getPixelForValue(prediction);ctx.fillRect(x1Pixel,yTopPixel,x2Pixel-x1Pixel,yBottomPixel-yTopPixel)}}ctx.restore()}}}getPredictionLinesPlugin(){const demo=this;return{id:"predictionLines",beforeDatasetsDraw(chart){if(!demo.dataPoints||0===demo.dataPoints.length)return;const ctx=chart.ctx,xScale=chart.scales.x,yScale=chart.scales.y,alpha=parseFloat(demo.alphaSlider.value),beta=parseFloat(demo.betaSlider.value);ctx.save(),demo.dataPoints.forEach(point=>{const prediction=demo.predict(point.x,alpha,beta,demo.classifierType),isCorrect=demo.classify(point.x,alpha,beta,demo.classifierType)===point.y,xPixel=xScale.getPixelForValue(point.x),yPointPixel=yScale.getPixelForValue(point.y),yPredPixel=yScale.getPixelForValue(prediction);if(isCorrect){const distanceFrom05=Math.abs(prediction-.5);let lineColor;lineColor=distanceFrom05>=.35?"rgba(46, 204, 113, 1)":distanceFrom05>=.2?"rgba(255, 193, 7, 1)":"rgba(231, 76, 60, 1)",ctx.setLineDash([3,3]),ctx.lineWidth=2.5,ctx.strokeStyle=lineColor,ctx.beginPath(),ctx.moveTo(xPixel,yPointPixel),ctx.lineTo(xPixel,yPredPixel),ctx.stroke()}else{const zigzagAmplitude=3,zigzagSegments=20,segmentHeight=Math.abs(yPredPixel-yPointPixel)/zigzagSegments,direction=yPredPixel<yPointPixel?-1:1;ctx.setLineDash([]),ctx.lineWidth=1.5,ctx.strokeStyle="rgba(149, 165, 166, 0.6)",ctx.beginPath(),ctx.moveTo(xPixel,yPointPixel);for(let i=1;i<=zigzagSegments;i++){const yPos=yPointPixel+direction*segmentHeight*i,xOffset=i%2==0?zigzagAmplitude:-zigzagAmplitude;ctx.lineTo(xPixel+xOffset,yPos)}ctx.stroke()}}),ctx.restore()},afterDatasetsDraw(chart){if(!demo.dataPoints||0===demo.dataPoints.length)return;const ctx=chart.ctx,xScale=chart.scales.x,yScale=chart.scales.y,alpha=parseFloat(demo.alphaSlider.value),beta=parseFloat(demo.betaSlider.value);ctx.save(),ctx.setLineDash([]),ctx.lineWidth=2.5;demo.dataPoints.forEach(point=>{const isCorrect=demo.classify(point.x,alpha,beta,demo.classifierType)===point.y,xPixel=xScale.getPixelForValue(point.x),yPointPixel=yScale.getPixelForValue(point.y);if(isCorrect?(ctx.strokeStyle="white",ctx.beginPath(),ctx.moveTo(xPixel-5.5,yPointPixel),ctx.lineTo(xPixel-2.75,yPointPixel+5.5),ctx.lineTo(xPixel+5.5,yPointPixel-5.5),ctx.stroke()):(ctx.strokeStyle="white",ctx.beginPath(),ctx.moveTo(xPixel-5.5,yPointPixel-5.5),ctx.lineTo(xPixel+5.5,yPointPixel+5.5),ctx.moveTo(xPixel+5.5,yPointPixel-5.5),ctx.lineTo(xPixel-5.5,yPointPixel+5.5),ctx.stroke()),void 0!==point.sortedID){ctx.font="bold 11px sans-serif",ctx.textAlign="center";const labelOffset=18,text=point.sortedID.toString(),textWidth=ctx.measureText(text).width,textHeight=11,padding=3;let labelY,labelX=xPixel;labelY=0===point.y?yPointPixel+labelOffset:yPointPixel-labelOffset,ctx.fillStyle="#ffeb3b";const boxX=labelX-textWidth/2-padding,boxY=labelY-textHeight+1,boxWidth=textWidth+2*padding,boxHeight=textHeight+padding;ctx.fillRect(boxX,boxY,boxWidth,boxHeight),ctx.fillStyle="#2c3e50",ctx.fillText(text,labelX,labelY)}}),ctx.restore()}}}initializeChart(){this.chart=new Chart(this.canvas.getContext("2d"),{type:"scatter",plugins:[this.getConfidenceRegionsPlugin(),this.getPredictionLinesPlugin()],data:{datasets:[{label:"Class 0",data:[],backgroundColor:[],borderColor:[],borderWidth:2,pointRadius:8,pointHoverRadius:10,showLine:!1},{label:"Class 1",data:[],backgroundColor:[],borderColor:[],borderWidth:2,pointRadius:8,pointHoverRadius:10,showLine:!1},{label:"Decision Boundary",data:[],backgroundColor:"transparent",borderColor:"#9b59b6",borderWidth:3,pointRadius:0,pointHoverRadius:0,showLine:!0,fill:!1,tension:0}]},options:{responsive:!0,maintainAspectRatio:!1,scales:{x:{type:"linear",position:"bottom",min:this.xMin,max:this.xMax,title:{display:!0,text:"X"},grid:{color:"#e0e0e0"}},y:{type:"linear",position:"left",min:this.yMin,max:this.yMax,title:{display:!0,text:"Y"},ticks:{autoSkip:!1,callback:function(value){return[0,.2,.4,.6,.8,1].includes(value)?value.toFixed(1):""}},afterBuildTicks:function(axis){axis.ticks=[{value:0},{value:.2},{value:.4},{value:.6},{value:.8},{value:1}]},grid:{color:function(context){const value=context.tick.value;return 0===value||1===value?"#000000":value>=0&&value<=1?"#e0e0e0":"transparent"},lineWidth:function(context){const value=context.tick.value;return 0===value||1===value?3:1}}}},plugins:{legend:{display:!1},tooltip:{filter:tooltipItem=>tooltipItem.datasetIndex<2}},onClick:(event,activeElements)=>{this.handleChartClick(event)},animation:{duration:0}}})}initializeDisplay(){this.updateChart(),this.updateDisplayPlainText(),window.MathJax&&(MathJax.startup&&MathJax.startup.promise?MathJax.startup.promise.then(()=>{this.updateDisplay()}).catch(()=>{console.warn("MathJax failed to load, using plain text equations")}):setTimeout(()=>{this.updateDisplay()},100))}updateDisplayPlainText(){const alpha=parseFloat(this.alphaSlider.value),beta=parseFloat(this.betaSlider.value);this.alphaValue.textContent=alpha.toFixed(1),this.betaValue.textContent=beta.toFixed(1);const betaSign=beta>=0?"+":"-";let functionName,equationText;functionName="sigmoid"===this.classifierType?"σ(x)":"step"===this.classifierType?"H(x)":"f(x)",equationText="sigmoid"===this.classifierType?`${functionName} = σ(${alpha.toFixed(1)}x ${betaSign} ${Math.abs(beta).toFixed(1)})`:"step"===this.classifierType?`${functionName} = H(${alpha.toFixed(1)}x ${betaSign} ${Math.abs(beta).toFixed(1)})`:`${functionName} = ${alpha.toFixed(1)}x ${betaSign} ${Math.abs(beta).toFixed(1)}`,this.equation.textContent=equationText;const accuracy=this.calculateAccuracy(alpha,beta,this.classifierType),loss=this.calculateLoss(alpha,beta,this.classifierType);this.accuracyDisplay.update(100*accuracy,!1),this.lossDisplay.update(loss,!1)}setupEventListeners(){this.alphaSlider.addEventListener("input",()=>{this.updateDisplay(),this.updateChart()}),this.betaSlider.addEventListener("input",()=>{this.updateDisplay(),this.updateChart()}),this.classifierBoxes.forEach(box=>{box.addEventListener("click",()=>{this.classifierBoxes.forEach(b=>b.classList.remove("active")),box.classList.add("active"),this.classifierType=box.dataset.type,this.updateDisplay(),this.updateChart()})}),this.solutionBtn.addEventListener("click",()=>{this.setOptimalValues()}),this.generateDataBtn.addEventListener("click",()=>{this.generateNewData()}),this.clearDataBtn.addEventListener("click",()=>{this.clearAllData()})}updateDisplay(){const alpha=parseFloat(this.alphaSlider.value),beta=parseFloat(this.betaSlider.value);this.alphaValue.textContent=alpha.toFixed(1),this.betaValue.textContent=beta.toFixed(1);const betaSign=beta>=0?"+":"-",betaValue=Math.abs(beta).toFixed(1),linearPart=`${alpha.toFixed(1)}x ${betaSign} ${betaValue}`;"sigmoid"===this.classifierType?this.equation.innerHTML=`$$f(x) = \\sigma(${linearPart})$$`:"step"===this.classifierType?this.equation.innerHTML=`$$f(x) = H(${linearPart})$$`:this.equation.innerHTML=`$$f(x) = ${linearPart}$$`,window.MathJax&&MathJax.typesetPromise([this.equation]).catch(err=>console.log(err));const accuracy=this.calculateAccuracy(alpha,beta,this.classifierType),loss=this.calculateLoss(alpha,beta,this.classifierType);MetricLabel.batchUpdate([{display:this.accuracyDisplay,value:100*accuracy},{display:this.lossDisplay,value:loss}])}sigmoid(x){return 1/(1+Math.exp(-x))}predict(x,alpha,beta,classifierType){const linear=alpha*x+beta;return"sigmoid"===classifierType?this.sigmoid(linear):"step"===classifierType?linear>0?1:0:Math.max(0,Math.min(1,linear))}classify(x,alpha,beta,classifierType){const prediction=this.predict(x,alpha,beta,classifierType);return"step"===classifierType?prediction:prediction>.5?1:0}calculateAccuracy(alpha,beta,classifierType){if(0===this.dataPoints.length)return 0;let correct=0;return this.dataPoints.forEach(point=>{this.classify(point.x,alpha,beta,classifierType)===point.y&&correct++}),correct/this.dataPoints.length}calculateLoss(alpha,beta,classifierType){if(0===this.dataPoints.length)return 0;let totalLoss=0;return this.dataPoints.forEach(point=>{const prediction=this.predict(point.x,alpha,beta,classifierType);if("sigmoid"===classifierType){const epsilon=1e-15,clippedPred=Math.max(epsilon,Math.min(1-epsilon,prediction));totalLoss+=-(point.y*Math.log(clippedPred)+(1-point.y)*Math.log(1-clippedPred))}else totalLoss+=Math.pow(point.y-prediction,2)}),totalLoss/this.dataPoints.length}setOptimalValues(){0!==this.dataPoints.length&&("sigmoid"===this.classifierType?this.optimizeForClassification():"step"===this.classifierType?this.optimizeStepFunction():this.optimizeForRegression(),this.updateDisplay(),this.updateChart())}optimizeForRegression(){if(0===this.dataPoints.length)return;const sortedPoints=[...this.dataPoints].sort((a,b)=>a.x-b.x),class0=this.dataPoints.filter(p=>0===p.y),class1=this.dataPoints.filter(p=>1===p.y);if(0===class0.length||0===class1.length)return;const mean0=class0.reduce((sum,p)=>sum+p.x,0)/class0.length,usePositiveAlpha=class1.reduce((sum,p)=>sum+p.x,0)/class1.length>mean0,uniqueX=[...new Set(sortedPoints.map(p=>p.x))].sort((a,b)=>a-b);let bestAccuracy=0,bestBoundaryX=0;for(let i=0;i<uniqueX.length-1;i++){const boundaryX=(uniqueX[i]+uniqueX[i+1])/2;let correct=0;this.dataPoints.forEach(point=>{let predicted;predicted=usePositiveAlpha?point.x>boundaryX?1:0:point.x<boundaryX?1:0,predicted===point.y&&correct++});const accuracy=correct/this.dataPoints.length;accuracy>bestAccuracy&&(bestAccuracy=accuracy,bestBoundaryX=boundaryX)}[sortedPoints[0].x-1,sortedPoints[sortedPoints.length-1].x+1].forEach(boundaryX=>{let correct=0;this.dataPoints.forEach(point=>{let predicted;predicted=usePositiveAlpha?point.x>boundaryX?1:0:point.x<boundaryX?1:0,predicted===point.y&&correct++});const accuracy=correct/this.dataPoints.length;accuracy>bestAccuracy&&(bestAccuracy=accuracy,bestBoundaryX=boundaryX)});let alpha=usePositiveAlpha?1:-1,beta=.5-alpha*bestBoundaryX;const clampedAlpha=Math.max(-5,Math.min(5,alpha)),clampedBeta=Math.max(-10,Math.min(10,beta));this.alphaSlider.value=clampedAlpha.toFixed(1),this.betaSlider.value=clampedBeta.toFixed(1)}optimizeForClassification(){if(0===this.dataPoints.length)return;const sortedPoints=[...this.dataPoints].sort((a,b)=>a.x-b.x),class0=this.dataPoints.filter(p=>0===p.y),class1=this.dataPoints.filter(p=>1===p.y);if(0===class0.length||0===class1.length)return;const mean0=class0.reduce((sum,p)=>sum+p.x,0)/class0.length,mean1=class1.reduce((sum,p)=>sum+p.x,0)/class1.length,usePositiveAlpha=mean1>mean0,uniqueX=[...new Set(sortedPoints.map(p=>p.x))].sort((a,b)=>a-b);let bestAccuracy=0,bestBoundaryX=(mean0+mean1)/2;for(let i=0;i<uniqueX.length-1;i++){const boundaryX=(uniqueX[i]+uniqueX[i+1])/2;let correct=0;this.dataPoints.forEach(point=>{(usePositiveAlpha?point.x>boundaryX?1:0:point.x<boundaryX?1:0)===point.y&&correct++});const accuracy=correct/this.dataPoints.length;accuracy>bestAccuracy&&(bestAccuracy=accuracy,bestBoundaryX=boundaryX)}let alpha=usePositiveAlpha?2:-2,beta=-alpha*bestBoundaryX;for(let iter=0;iter<2e3;iter++){let alphaGrad=0,betaGrad=0;this.dataPoints.forEach(point=>{const z=alpha*point.x+beta,error=this.sigmoid(z)-point.y;alphaGrad+=error*point.x,betaGrad+=error}),alphaGrad/=this.dataPoints.length,betaGrad/=this.dataPoints.length;const decayedLR=.5/(1+iter/1e3);if(alpha-=decayedLR*alphaGrad,beta-=decayedLR*betaGrad,Math.abs(alphaGrad)<1e-4&&Math.abs(betaGrad)<1e-4)break}const clampedAlpha=Math.max(-5,Math.min(5,alpha)),clampedBeta=Math.max(-10,Math.min(10,beta));this.alphaSlider.value=clampedAlpha.toFixed(1),this.betaSlider.value=clampedBeta.toFixed(1)}optimizeStepFunction(){if(0===this.dataPoints.length)return;const sortedPoints=[...this.dataPoints].sort((a,b)=>a.x-b.x),class0=this.dataPoints.filter(p=>0===p.y),class1=this.dataPoints.filter(p=>1===p.y);if(0===class0.length||0===class1.length)return;const mean0=class0.reduce((sum,p)=>sum+p.x,0)/class0.length,usePositiveAlpha=class1.reduce((sum,p)=>sum+p.x,0)/class1.length>mean0,uniqueX=[...new Set(sortedPoints.map(p=>p.x))].sort((a,b)=>a-b);let bestAccuracy=0,bestBoundaryX=0;for(let i=0;i<uniqueX.length-1;i++){const boundaryX=(uniqueX[i]+uniqueX[i+1])/2;let correct=0;this.dataPoints.forEach(point=>{let predicted;predicted=usePositiveAlpha?point.x>boundaryX?1:0:point.x<boundaryX?1:0,predicted===point.y&&correct++});const accuracy=correct/this.dataPoints.length;accuracy>bestAccuracy&&(bestAccuracy=accuracy,bestBoundaryX=boundaryX)}[sortedPoints[0].x-1,sortedPoints[sortedPoints.length-1].x+1].forEach(boundaryX=>{let correct=0;this.dataPoints.forEach(point=>{let predicted;predicted=usePositiveAlpha?point.x>boundaryX?1:0:point.x<boundaryX?1:0,predicted===point.y&&correct++});const accuracy=correct/this.dataPoints.length;accuracy>bestAccuracy&&(bestAccuracy=accuracy,bestBoundaryX=boundaryX)});let alpha=usePositiveAlpha?1:-1,beta=-alpha*bestBoundaryX;const clampedAlpha=Math.max(-5,Math.min(5,alpha)),clampedBeta=Math.max(-10,Math.min(10,beta));this.alphaSlider.value=clampedAlpha.toFixed(1),this.betaSlider.value=clampedBeta.toFixed(1)}generateNewData(){this.clearAllData(),this.generateDataPoints(),this.updateDisplay(),this.updateChart()}clearAllData(){this.dataPoints=[],this.updateDisplay(),this.updateChart()}handleChartClick(event){const canvasPosition=Chart.helpers.getRelativePosition(event,this.chart),x=this.chart.scales.x.getValueForPixel(canvasPosition.x),y=this.chart.scales.y.getValueForPixel(canvasPosition.y);if(x>=this.xMin&&x<=this.xMax&&y>=this.yMin&&y<=this.yMax){const classLabel=y>.5?1:0;this.dataPoints.push({x:x,y:classLabel}),this.updateDisplay(),this.updateChart()}}updateChart(){if(!this.chart)return;this.assignSortedIDs();const alpha=parseFloat(this.alphaSlider.value),beta=parseFloat(this.betaSlider.value),class0Points=[],class0BackgroundColors=[],class0BorderColors=[],class1Points=[],class1BackgroundColors=[],class1BorderColors=[];this.dataPoints.forEach(point=>{const isCorrect=this.classify(point.x,alpha,beta,this.classifierType)===point.y,backgroundColor=isCorrect?"rgba(46, 204, 113, 0.8)":"rgba(231, 76, 60, 0.8)",borderColor=isCorrect?"rgba(46, 204, 113, 1)":"rgba(231, 76, 60, 1)";0===point.y?(class0Points.push({x:point.x,y:point.y}),class0BackgroundColors.push(backgroundColor),class0BorderColors.push(borderColor)):(class1Points.push({x:point.x,y:point.y}),class1BackgroundColors.push(backgroundColor),class1BorderColors.push(borderColor))}),this.chart.data.datasets[0].data=class0Points,this.chart.data.datasets[0].backgroundColor=class0BackgroundColors,this.chart.data.datasets[0].borderColor=class0BorderColors,this.chart.data.datasets[1].data=class1Points,this.chart.data.datasets[1].backgroundColor=class1BackgroundColors,this.chart.data.datasets[1].borderColor=class1BorderColors,this.chart.data.datasets[2].data=this.generateDecisionBoundaryData(),this.chart.update("none"),this.updatePredictionsTable()}updatePredictionsTable(){if(!this.dataPoints||0===this.dataPoints.length)return document.getElementById("tableIDRow").innerHTML="<th>ID</th>",document.getElementById("tableXRow").innerHTML="<th>$x$</th>",document.getElementById("tableTrueYRow").innerHTML="<th>True $y$</th>",document.getElementById("tablePredYRow").innerHTML="<th>Pred $y$</th>",document.getElementById("tableCorrectRow").innerHTML="<th>Correct</th>",void(document.getElementById("tableConfidenceRow").innerHTML="<th>Confidence</th>");const alpha=parseFloat(this.alphaSlider.value),beta=parseFloat(this.betaSlider.value),sortedPoints=[...this.dataPoints].sort((a,b)=>a.x-b.x);let idHTML="<th>ID</th>",xHTML="<th>$x$</th>",trueYHTML="<th>True $y$</th>",predYHTML="<th>Pred $y$</th>",correctHTML="<th>Correct</th>",confidenceHTML="<th>Confidence</th>";sortedPoints.forEach(point=>{const prediction=this.predict(point.x,alpha,beta,this.classifierType),predicted=this.classify(point.x,alpha,beta,this.classifierType),isCorrect=predicted===point.y,distanceFrom05=Math.abs(prediction-.5);let confidenceClass="";confidenceClass=distanceFrom05>=.35?"confidence-high":distanceFrom05>=.2?"confidence-medium":"confidence-low";const trueYClass=0===point.y?"class-0":"class-1";idHTML+=`<td>${point.sortedID}</td>`,xHTML+=`<td>${point.x.toFixed(2)}</td>`,trueYHTML+=`<td class="${trueYClass}">${point.y}</td>`,predYHTML+=`<td class="${confidenceClass}">${prediction.toFixed(2)}</td>`,correctHTML+=`<td class="${isCorrect?"correct-check":"incorrect-x"}">${isCorrect?"✓":"✗"}</td>`,confidenceHTML+=`<td class="${confidenceClass}">${(100*distanceFrom05).toFixed(1)}%</td>`}),document.getElementById("tableIDRow").innerHTML=idHTML,document.getElementById("tableXRow").innerHTML=xHTML,document.getElementById("tableTrueYRow").innerHTML=trueYHTML,document.getElementById("tablePredYRow").innerHTML=predYHTML,document.getElementById("tableCorrectRow").innerHTML=correctHTML,document.getElementById("tableConfidenceRow").innerHTML=confidenceHTML,window.MathJax&&window.MathJax.typesetPromise&&MathJax.typesetPromise([document.getElementById("predictionsTable")]).catch(err=>console.log(err))}generateDecisionBoundaryData(){const alpha=parseFloat(this.alphaSlider.value),beta=parseFloat(this.betaSlider.value),boundaryPoints=[],stepSize=(this.xMax-this.xMin)/200;for(let i=0;i<=200;i++){const x=this.xMin+i*stepSize;let y;if("sigmoid"===this.classifierType)y=1/(1+Math.exp(-(alpha*x+beta)));else if("step"===this.classifierType){y=alpha*x+beta>0?1:0}else{const linear=alpha*x+beta;y=Math.max(0,Math.min(1,linear))}y>=this.yMin&&y<=this.yMax&&boundaryPoints.push({x:x,y:y})}return boundaryPoints}}document.addEventListener("DOMContentLoaded",()=>{new ClassificationDemo});