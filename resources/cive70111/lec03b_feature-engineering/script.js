class MultiLinearRegressionDemo{constructor(){this.featureMetadata=[{key:"latitude",icon:"ðŸ—ºï¸",label:"Latitude",className:"feature-latitude"},{key:"longitude",icon:"ðŸŒ",label:"Longitude",className:"feature-longitude"},{key:"bathrooms",icon:"ðŸš¿",label:"Bathrooms",className:"feature-bathrooms"},{key:"bedrooms",icon:"ðŸ›ï¸",label:"Bedrooms",className:"feature-bedrooms"},{key:"floorAreaSqM",icon:"ðŸ“",label:"Floor Area",className:"feature-floor-area"},{key:"livingRooms",icon:"ðŸ›‹ï¸",label:"Living Rooms",className:"feature-living-rooms"},{key:"distance_to_tube",icon:"ðŸš‡",label:"Dist. Tube",className:"feature-distance-tube"},{key:"distance_to_bus",icon:"ðŸšŒ",label:"Dist. Bus",className:"feature-distance-bus"},{key:"no_of_bus_1km",icon:"ðŸš",label:"Bus Stops",className:"feature-bus-stops"}],this.transformations=[{key:"x",label:"x",power:1},{key:"x2",label:"xÂ²",power:2},{key:"x3",label:"xÂ³",power:3},{key:"inv_x",label:"1/x",power:-1},{key:"inv_x2",label:"1/xÂ²",power:-2}],this.activeTransformations={},this.featureMetadata.forEach(feature=>{this.activeTransformations[feature.key]={x:!0}}),this.trainedTransformations=this.deepCopyTransformations(this.activeTransformations),this.retrainCountdownTimer=null,this.retrainCountdownSeconds=0,this.maeDisplay=new MetricLabel("mae","MAE",{theme:"green",label:"Mean Absolute Error",decimals:2}),this.mseDisplay=new MetricLabel("mse","MSE",{theme:"purple",label:"Mean Squared Error",decimals:0,thousandsSeparator:!0}),this.r2Display=new MetricLabel("r2","RÂ²",{theme:"blue",label:"RÂ² Score",decimals:3}),this.featureCountDisplay=new MetricLabel("feature-count","Features",{theme:"orange",label:"Active Features",decimals:0,separator:":"}),this.trainData=[],this.testData=[],this.fullTrainData=[],this.model=null,this.labelKey="saleEstimate_currentPrice",this.saleEstimateStats={mean:0,std:1},this.datasetMode="train",this.chart=null,this.lossHistory=[],this.lossCanvas=null,this.lossCtx=null,this.maxExpectedIterations=0,this.isTraining=!1,this.cancelTraining=!1,this.randomSeed=42,this.currentTab=null,this.lassoMode=!1,this.lambdaStrength=0,this.savedTransformations=null,this.generateFeatureUI(),this.setupDatasetToggle(),this.setupModelButtons(),this.initializeLossCurve(),this.loadData(),this.initializeChart(),this.infotab=new InfoTab({onTabChange:tabId=>{this.currentTab=tabId;const wasLassoMode=this.lassoMode,isLassoMode="lasso"===tabId;isLassoMode&&!wasLassoMode?this.enterLassoMode():!isLassoMode&&wasLassoMode&&this.exitLassoMode(),window.MathJax&&window.MathJax.typesetPromise&&MathJax.typesetPromise().catch(err=>console.log("MathJax error:",err))}})}generateFeatureUI(){const grid=document.querySelector(".feature-engineering-grid");grid.innerHTML="";const headerRow=document.createElement("div");headerRow.className="feature-header-row";const cornerCell=document.createElement("div");cornerCell.className="transform-label-cell",headerRow.appendChild(cornerCell),this.featureMetadata.forEach(feature=>{const iconBox=document.createElement("div");iconBox.className=`feature-icon-box ${feature.className}`,iconBox.dataset.feature=feature.key,iconBox.innerHTML=`\n                <div class="icon">${feature.icon}</div>\n                <div class="label">${feature.label}</div>\n            `,iconBox.addEventListener("click",()=>{this.toggleFeatureColumn(feature.key)}),headerRow.appendChild(iconBox)}),grid.appendChild(headerRow),this.transformations.forEach(transform=>{const row=document.createElement("div");row.className="transformation-row",row.dataset.transform=transform.key;const rowToggle=document.createElement("div");rowToggle.className="transform-row-toggle",rowToggle.dataset.transform=transform.key,rowToggle.textContent=transform.label,"x"===transform.key&&rowToggle.classList.add("active"),rowToggle.addEventListener("click",()=>{this.toggleTransformationRow(transform.key)}),row.appendChild(rowToggle),this.featureMetadata.forEach(feature=>{const toggle=document.createElement("div");toggle.className="transform-toggle",toggle.dataset.feature=feature.key,toggle.dataset.transform=transform.key,toggle.textContent=transform.label,"x"===transform.key&&toggle.classList.add("active"),toggle.addEventListener("click",()=>{this.toggleTransformation(feature.key,transform.key,toggle)}),row.appendChild(toggle)}),grid.appendChild(row)}),this.featureMetadata.forEach(feature=>{this.updateFeatureColumnState(feature.key)})}generateCoefficientVisualization(){if(!this.model||!this.model.theta)return void console.warn("Cannot generate coefficient visualization: model not trained");const grid=document.querySelector(".feature-engineering-grid");grid.innerHTML="";const theta=this.model.theta,activeFeatures=this.getActiveFeatureTransformations(),coefficients=theta.slice(1),maxAbsCoef=Math.max(...coefficients.map(c=>Math.abs(c))),headerRow=document.createElement("div");headerRow.className="feature-header-row";const cornerCell=document.createElement("div");cornerCell.className="transform-label-cell",headerRow.appendChild(cornerCell),this.featureMetadata.forEach(feature=>{const iconBox=document.createElement("div");iconBox.className=`feature-icon-box ${feature.className}`,iconBox.style.opacity="0.6",iconBox.innerHTML=`\n                <div class="icon">${feature.icon}</div>\n                <div class="label">${feature.label}</div>\n            `,headerRow.appendChild(iconBox)}),grid.appendChild(headerRow),this.transformations.forEach(transform=>{const row=document.createElement("div");row.className="transformation-row";const rowLabel=document.createElement("div");rowLabel.className="transform-row-toggle",rowLabel.textContent=transform.label,rowLabel.style.opacity="0.6",rowLabel.style.cursor="default",rowLabel.style.pointerEvents="none",row.appendChild(rowLabel),this.featureMetadata.forEach(feature=>{const coeffBox=document.createElement("div");coeffBox.className="coefficient-box";const featureIndex=activeFeatures.findIndex(f=>f.featureKey===feature.key&&f.transformKey===transform.key);if(-1!==featureIndex){const coef=coefficients[featureIndex],absCoef=Math.abs(coef);if(absCoef<.001)coeffBox.classList.add("zero");else{const saturation=maxAbsCoef>0?Math.min(1,absCoef/maxAbsCoef):0;if(coef>0){coeffBox.classList.add("positive");const baseColor={r:22,g:163,b:74},white={r:255,g:255,b:255},r=Math.round(white.r+(baseColor.r-white.r)*saturation),g=Math.round(white.g+(baseColor.g-white.g)*saturation),b=Math.round(white.b+(baseColor.b-white.b)*saturation);coeffBox.style.backgroundColor=`rgb(${r}, ${g}, ${b})`}else{coeffBox.classList.add("negative");const baseColor={r:220,g:38,b:38},white={r:255,g:255,b:255},r=Math.round(white.r+(baseColor.r-white.r)*saturation),g=Math.round(white.g+(baseColor.g-white.g)*saturation),b=Math.round(white.b+(baseColor.b-white.b)*saturation);coeffBox.style.backgroundColor=`rgb(${r}, ${g}, ${b})`}}}else coeffBox.classList.add("zero");row.appendChild(coeffBox)}),grid.appendChild(row)})}setupDatasetToggle(){const trainToggle=document.getElementById("toggle-train"),testToggle=document.getElementById("toggle-test");trainToggle.addEventListener("click",()=>{"train"!==this.datasetMode&&(this.datasetMode="train",trainToggle.classList.add("active"),testToggle.classList.remove("active"),this.updateDisplay(),this.updateChart())}),testToggle.addEventListener("click",()=>{"test"!==this.datasetMode&&(this.datasetMode="test",testToggle.classList.add("active"),trainToggle.classList.remove("active"),this.updateDisplay(),this.updateChart())})}setupModelButtons(){const trainBtn=document.getElementById("train-model-btn"),resetBtn=document.getElementById("reset-features-btn");trainBtn.addEventListener("click",()=>{this.trainModelWithCurrentFeatures()}),resetBtn.addEventListener("click",()=>{this.resetFeaturesToTrainedModel()})}enterLassoMode(){console.log("Entering Lasso mode"),this.lassoMode=!0,this.savedTransformations=this.deepCopyTransformations(this.activeTransformations),this.featureMetadata.forEach(feature=>{this.transformations.forEach(transform=>{this.activeTransformations[feature.key][transform.key]=!0})});const trainBtn=document.getElementById("train-model-btn"),resetBtn=document.getElementById("reset-features-btn");trainBtn&&(trainBtn.style.display="none"),resetBtn&&(resetBtn.style.display="none");const lambdaControls=document.getElementById("lambda-controls");lambdaControls&&(lambdaControls.style.display="block",this.setupLambdaControls()),this.setTogglesEnabled(!1),this.updateFeatureCount(),this.updateLossCanvasSize(),this.trainModelWithCurrentFeatures()}exitLassoMode(){console.log("Exiting Lasso mode"),this.lassoMode=!1,this.savedTransformations&&(this.activeTransformations=this.deepCopyTransformations(this.savedTransformations),this.savedTransformations=null,this.transformations.forEach(transform=>{this.featureMetadata.forEach(feature=>{const toggle=document.querySelector(`.transform-toggle[data-feature="${feature.key}"][data-transform="${transform.key}"]`);toggle&&(this.activeTransformations[feature.key][transform.key]?toggle.classList.add("active"):toggle.classList.remove("active"))}),this.updateRowToggleState(transform.key)}),this.featureMetadata.forEach(feature=>{this.updateFeatureColumnState(feature.key)}));const trainBtn=document.getElementById("train-model-btn"),resetBtn=document.getElementById("reset-features-btn");trainBtn&&(trainBtn.style.display="block"),resetBtn&&(resetBtn.style.display="block");const lambdaControls=document.getElementById("lambda-controls");lambdaControls&&(lambdaControls.style.display="none"),this.setTogglesEnabled(!0),this.generateFeatureUI(),this.updateFeatureCount(),this.updateLossCanvasSize(),this.trainModelWithCurrentFeatures()}setupLambdaControls(){const lambdaBtns=document.querySelectorAll(".lambda-btn");lambdaBtns.forEach(btn=>{btn.addEventListener("click",()=>{lambdaBtns.forEach(b=>b.classList.remove("active")),btn.classList.add("active"),this.lambdaStrength=parseFloat(btn.getAttribute("data-lambda")),this.trainModelWithCurrentFeatures()})})}initializeLossCurve(){this.lossCanvas=document.getElementById("loss-curve-canvas"),this.lossCanvas&&(this.updateLossCanvasSize(),this.drawLossCurve(),window.addEventListener("resize",()=>{this.updateLossCanvasSize(),this.drawLossCurve()}))}updateLossCanvasSize(){if(!this.lossCanvas)return;const dpr=window.devicePixelRatio||1,rect=this.lossCanvas.getBoundingClientRect(),width=rect.width,height=rect.height;this.lossCanvas.width=width*dpr,this.lossCanvas.height=height*dpr,this.lossCtx=this.lossCanvas.getContext("2d"),this.lossCtx.scale(dpr,dpr)}drawLossCurve(){if(!this.lossCtx||!this.lossCanvas)return;const ctx=this.lossCtx,rect=this.lossCanvas.getBoundingClientRect(),width=rect.width,height=rect.height,dpr=window.devicePixelRatio||1;if(ctx.clearRect(0,0,this.lossCanvas.width/dpr,this.lossCanvas.height/dpr),ctx.fillStyle="#f9fafb",ctx.fillRect(0,0,width,height),0===this.lossHistory.length)return ctx.fillStyle="#9ca3af",ctx.font="14px sans-serif",ctx.textAlign="center",ctx.textBaseline="middle",void ctx.fillText("Training loss will appear here",width/2,height/2);const maxLoss=Math.max(...this.lossHistory),lossRange=maxLoss-0||1,plotWidth=width-50-10,plotHeight=height-20-20;if(ctx.strokeStyle="#6b7280",ctx.lineWidth=1,ctx.beginPath(),ctx.moveTo(50,20),ctx.lineTo(50,height-20),ctx.lineTo(width-10,height-20),ctx.stroke(),this.lossHistory.length>0){const progressWidth=plotWidth*(this.lossHistory.length/this.maxExpectedIterations);ctx.fillStyle="rgba(59, 130, 246, 0.05)",ctx.fillRect(50,20,progressWidth,plotHeight)}ctx.strokeStyle="#3b82f6",ctx.lineWidth=2,ctx.beginPath(),this.lossHistory.forEach((loss,i)=>{const x=50+i/this.maxExpectedIterations*plotWidth,y=height-20-(loss-0)/lossRange*plotHeight;0===i?ctx.moveTo(x,y):ctx.lineTo(x,y)}),ctx.stroke();const currentX=50+plotWidth*(this.lossHistory.length/this.maxExpectedIterations);this.lossHistory.length<this.maxExpectedIterations&&(ctx.strokeStyle="#9ca3af",ctx.lineWidth=1,ctx.setLineDash([3,3]),ctx.beginPath(),ctx.moveTo(currentX,20),ctx.lineTo(currentX,height-20),ctx.stroke(),ctx.setLineDash([])),ctx.fillStyle="#374151",ctx.font="11px sans-serif",ctx.textAlign="right",ctx.textBaseline="middle";const formatValue=val=>0===val?"0":val>=1?val.toFixed(2):val>=.01?val.toFixed(4):val.toExponential(2);ctx.fillText(formatValue(maxLoss),45,20),ctx.fillText(formatValue(0),45,height-20);const midLoss=(maxLoss+0)/2,midY=height-20-(midLoss-0)/lossRange*plotHeight;ctx.fillText(formatValue(midLoss),45,midY),ctx.textAlign="right",ctx.textBaseline="top";const progressPercent=Math.round(this.lossHistory.length/this.maxExpectedIterations*100);ctx.fillText(`${progressPercent}%`,width-10,height-20+5),ctx.textAlign="left",ctx.textBaseline="bottom",ctx.fillText("Loss",50,15)}deepCopyTransformations(transformations){const copy={};return Object.keys(transformations).forEach(featureKey=>{copy[featureKey]={...transformations[featureKey]}}),copy}seededRandom(seed){let state=seed;return function(){state|=0,state=state+1831565813|0;let t=Math.imul(state^state>>>15,1|state);return t=t+Math.imul(t^t>>>7,61|t)^t,((t^t>>>14)>>>0)/4294967296}}async trainModelWithCurrentFeatures(){this.stopRetrainCountdown(),this.cancelTraining=!0;let waitCount=0;for(;this.isTraining&&waitCount<50;)await new Promise(resolve=>setTimeout(resolve,10)),waitCount++;this.cancelTraining=!1,this.isTraining=!0,this.setTogglesEnabled(!1);const trainingBadge=document.getElementById("training-badge"),retrainBadge=document.getElementById("retrain-badge");trainingBadge&&(trainingBadge.style.display="block"),retrainBadge&&(retrainBadge.style.display="none"),this.trainedTransformations=this.deepCopyTransformations(this.activeTransformations),this.lossHistory=[],this.drawLossCurve(),await this.trainModel(),trainingBadge&&(trainingBadge.style.display="none"),this.updateRetrainBadge(),this.isTraining=!1,this.setTogglesEnabled(!0),this.updateTrainButtonText()}resetFeaturesToTrainedModel(){this.activeTransformations=this.deepCopyTransformations(this.trainedTransformations),this.transformations.forEach(transform=>{this.featureMetadata.forEach(feature=>{const toggle=document.querySelector(`.transform-toggle[data-feature="${feature.key}"][data-transform="${transform.key}"]`);toggle&&(this.activeTransformations[feature.key][transform.key]?toggle.classList.add("active"):toggle.classList.remove("active"))}),this.updateRowToggleState(transform.key)}),this.featureMetadata.forEach(feature=>{this.updateFeatureColumnState(feature.key)}),this.updateFeatureCount(),this.updateRetrainBadge()}toggleTransformation(featureKey,transformKey,toggleElement){if(this.isTraining)return;this.activeTransformations[featureKey][transformKey]||!1?(delete this.activeTransformations[featureKey][transformKey],toggleElement.classList.remove("active")):(this.activeTransformations[featureKey][transformKey]=!0,toggleElement.classList.add("active")),this.updateRowToggleState(transformKey),this.updateFeatureColumnState(featureKey),this.startRetrainCountdown(),this.updateFeatureCount(),this.updateRetrainBadge()}toggleTransformationRow(transformKey){if(this.isTraining)return;let activeCount=0;this.featureMetadata.forEach(feature=>{this.activeTransformations[feature.key][transformKey]&&activeCount++});const shouldEnable=0===activeCount;this.featureMetadata.forEach(feature=>{shouldEnable?this.activeTransformations[feature.key][transformKey]=!0:delete this.activeTransformations[feature.key][transformKey];const toggle=document.querySelector(`.transform-toggle[data-feature="${feature.key}"][data-transform="${transformKey}"]`);toggle&&(shouldEnable?toggle.classList.add("active"):toggle.classList.remove("active"))}),this.updateRowToggleState(transformKey),this.featureMetadata.forEach(feature=>{this.updateFeatureColumnState(feature.key)}),this.updateFeatureCount(),this.updateRetrainBadge(),this.startRetrainCountdown()}toggleFeatureColumn(featureKey){if(this.isTraining)return;let activeCount=0;this.transformations.forEach(transform=>{this.activeTransformations[featureKey][transform.key]&&activeCount++});const shouldEnable=0===activeCount;this.transformations.forEach(transform=>{shouldEnable?this.activeTransformations[featureKey][transform.key]=!0:delete this.activeTransformations[featureKey][transform.key];const toggle=document.querySelector(`.transform-toggle[data-feature="${featureKey}"][data-transform="${transform.key}"]`);toggle&&(shouldEnable?toggle.classList.add("active"):toggle.classList.remove("active"))}),this.updateFeatureColumnState(featureKey),this.transformations.forEach(transform=>{this.updateRowToggleState(transform.key)}),this.updateFeatureCount(),this.updateRetrainBadge(),this.startRetrainCountdown()}updateRowToggleState(transformKey){let activeCount=0;this.featureMetadata.forEach(feature=>{this.activeTransformations[feature.key][transformKey]&&activeCount++});const rowToggle=document.querySelector(`.transform-row-toggle[data-transform="${transformKey}"]`);rowToggle&&(rowToggle.classList.remove("active","semi-active"),activeCount===this.featureMetadata.length?rowToggle.classList.add("active"):activeCount>0&&rowToggle.classList.add("semi-active"))}updateFeatureColumnState(featureKey){let activeCount=0;this.transformations.forEach(transform=>{this.activeTransformations[featureKey][transform.key]&&activeCount++});const iconBox=document.querySelector(`.feature-icon-box[data-feature="${featureKey}"]`);iconBox&&(iconBox.classList.remove("active","semi-active"),activeCount===this.transformations.length?iconBox.classList.add("active"):activeCount>0&&iconBox.classList.add("semi-active"))}updateFeatureCount(){let count=0;Object.values(this.activeTransformations).forEach(transforms=>{count+=Object.keys(transforms).length}),this.featureCountDisplay.update(count)}updateRetrainBadge(){const badge=document.getElementById("retrain-badge");if(!badge)return;!this.deepCompareTransformations(this.activeTransformations,this.trainedTransformations)?(this.retrainCountdownSeconds>0?badge.textContent=`New configuration - retraining in ${this.retrainCountdownSeconds}`:badge.textContent="New configuration - Please Retrain",badge.style.display="block"):badge.style.display="none"}startRetrainCountdown(){console.log("Starting retrain countdown..."),this.retrainCountdownTimer&&(clearInterval(this.retrainCountdownTimer),this.retrainCountdownTimer=null),this.retrainCountdownSeconds=5,this.updateTrainButtonText(),this.updateRetrainBadge(),this.retrainCountdownTimer=setInterval(()=>{this.retrainCountdownSeconds--,this.retrainCountdownSeconds<=0?(clearInterval(this.retrainCountdownTimer),this.retrainCountdownTimer=null,this.trainModelWithCurrentFeatures()):(this.updateTrainButtonText(),this.updateRetrainBadge())},1e3)}stopRetrainCountdown(){this.retrainCountdownTimer&&(clearInterval(this.retrainCountdownTimer),this.retrainCountdownTimer=null,this.retrainCountdownSeconds=0,this.updateTrainButtonText(),this.updateRetrainBadge())}updateTrainButtonText(){const featureCountBox=document.getElementById("feature-count");if(featureCountBox)if(this.retrainCountdownSeconds>0){const labelEl=featureCountBox.querySelector(".metric-label"),valueEl=featureCountBox.querySelector(".metric-value");labelEl&&(labelEl.textContent="Retraining in"),valueEl&&(valueEl.textContent=this.retrainCountdownSeconds)}else this.updateFeatureCount()}deepCompareTransformations(config1,config2){const keys1=Object.keys(config1),keys2=Object.keys(config2);if(keys1.length!==keys2.length)return!1;for(const featureKey of keys1){if(!config2[featureKey])return!1;const transforms1=Object.keys(config1[featureKey]),transforms2=Object.keys(config2[featureKey]);if(transforms1.length!==transforms2.length)return!1;for(const transformKey of transforms1)if(!config2[featureKey][transformKey])return!1}return!0}setTogglesEnabled(enabled){document.querySelectorAll(".transform-toggle").forEach(toggle=>{enabled?(toggle.classList.remove("disabled"),toggle.style.pointerEvents="auto",toggle.style.opacity="1"):(toggle.classList.add("disabled"),toggle.style.pointerEvents="none",toggle.style.opacity="0.5")});document.querySelectorAll(".transform-row-toggle").forEach(toggle=>{enabled?(toggle.style.pointerEvents="auto",toggle.style.opacity="1"):(toggle.style.pointerEvents="none",toggle.style.opacity="0.5")});document.querySelectorAll(".feature-icon-box").forEach(icon=>{enabled?(icon.style.pointerEvents="auto",icon.style.opacity="1"):(icon.style.pointerEvents="none",icon.style.opacity="0.5")});const trainBtn=document.getElementById("train-model-btn"),resetBtn=document.getElementById("reset-features-btn");trainBtn&&(trainBtn.disabled=!enabled,trainBtn.style.opacity=enabled?"1":"0.5"),resetBtn&&(resetBtn.disabled=!enabled,resetBtn.style.opacity=enabled?"1":"0.5")}initializeChart(){const ctx=document.getElementById("prediction-plot").getContext("2d");this.chart=new Chart(ctx,{type:"scatter",data:{datasets:[{label:"Train Predictions",data:[],backgroundColor:"rgba(52, 152, 219, 0.6)",borderColor:"rgba(52, 152, 219, 0.6)",pointRadius:2,pointHoverRadius:4},{label:"Perfect Prediction",data:[],type:"line",borderColor:"#e74c3c",borderWidth:2,borderDash:[5,5],pointRadius:0,pointHoverRadius:0,fill:!1},{label:"Test Predictions",data:[],backgroundColor:"rgba(234, 179, 8, 0.6)",borderColor:"rgba(234, 179, 8, 0.6)",pointRadius:2,pointHoverRadius:4,hidden:!0}]},options:{responsive:!0,maintainAspectRatio:!1,plugins:{legend:{display:!0,position:"top"},tooltip:{callbacks:{label:function(context){return 0===context.datasetIndex?`Actual: Â£${(context.parsed.x/1e3).toFixed(0)}k, Predicted: Â£${(context.parsed.y/1e3).toFixed(0)}k`:context.dataset.label}}}},scales:{x:{type:"linear",position:"bottom",min:0,max:6e6,title:{display:!0,text:"Actual Sale Estimates (Â£1000s)",font:{size:14,weight:"bold"}},ticks:{callback:function(value){return`Â£${(value/1e3).toLocaleString()}`}},grid:{display:!0,color:"#f0f0f0"}},y:{type:"linear",min:0,max:6e6,title:{display:!0,text:"Predicted Sale Estimates (Â£1000s)",font:{size:14,weight:"bold"}},ticks:{callback:function(value){return`Â£${(value/1e3).toLocaleString()}`}},grid:{display:!0,color:"#f0f0f0"}}},interaction:{intersect:!1,mode:"point"}}})}async loadData(){try{const[trainResponse,testResponse]=await Promise.all([fetch("data/train.csv"),fetch("data/test.csv")]),trainText=await trainResponse.text(),testText=await testResponse.text();this.fullTrainData=this.parseCSV(trainText).slice(0,1e4);const fullTestData=this.parseCSV(testText);this.trainData=this.randomSample(this.fullTrainData,200),this.testData=this.randomSample(fullTestData,200),console.log(`Loaded ${this.fullTrainData.length} training samples (${this.trainData.length} for visualization) and ${this.testData.length} test samples`),this.calculateEstimateStats();const batchSize=128,numEpochs=5;this.maxExpectedIterations=Math.floor(this.fullTrainData.length/batchSize)*numEpochs,console.log(`Expected training steps: ${this.maxExpectedIterations} (${numEpochs} epochs, batch_size=${batchSize})`),this.updateFeatureCount(),this.trainModelWithCurrentFeatures()}catch(error){console.error("Error loading data:",error)}}parseCSV(text){const lines=text.trim().split("\n"),headers=lines[0].split(","),data=[];for(let i=1;i<lines.length;i++){const values=lines[i].split(","),row={};headers.forEach((header,index)=>{row[header]=parseFloat(values[index])}),data.push(row)}return data}randomSample(array,sampleSize){if(sampleSize>=array.length)return[...array];const rng=this.seededRandom(this.randomSeed+1e3),shuffled=[...array];for(let i=shuffled.length-1;i>0;i--){const j=Math.floor(rng()*(i+1));[shuffled[i],shuffled[j]]=[shuffled[j],shuffled[i]]}return shuffled.slice(0,sampleSize)}calculateEstimateStats(){const estimateValues=this.fullTrainData.map(row=>row[this.labelKey]),mean=estimateValues.reduce((sum,val)=>sum+val,0)/estimateValues.length,variance=estimateValues.reduce((sum,val)=>sum+Math.pow(val-mean,2),0)/estimateValues.length,std=Math.sqrt(variance);this.saleEstimateStats={mean:mean,std:std}}normalizeSaleEstimate(value){return this.saleEstimateStats.std>0?(value-this.saleEstimateStats.mean)/this.saleEstimateStats.std:0}denormalizeSaleEstimate(normalizedValue){return normalizedValue*this.saleEstimateStats.std+this.saleEstimateStats.mean}applyTransformation(value,power){if(1===power)return value;if(-1===power){const epsilon=.1;if(Math.abs(value)<epsilon)return 0;const result=1/value;return Math.max(-100,Math.min(100,result))}if(-2===power){const epsilon=.01;if(Math.abs(value)<epsilon)return 0;const result=1/(value*value);return Math.min(100,result)}return 2===power?value*value:3===power?value*value*value:Math.pow(value,power)}getActiveFeatureTransformations(){const activeFeatures=[];return Object.keys(this.activeTransformations).forEach(featureKey=>{const transforms=this.activeTransformations[featureKey];Object.keys(transforms).forEach(transformKey=>{const transformMeta=this.transformations.find(t=>t.key===transformKey);transformMeta&&activeFeatures.push({featureKey:featureKey,transformKey:transformKey,power:transformMeta.power,name:`${featureKey}_${transformKey}`})})}),activeFeatures}prepareFeatureMatrix(data){const activeFeatures=this.getActiveFeatureTransformations(),n=data.length,p=activeFeatures.length+1,X=Array(n).fill(null).map(()=>Array(p).fill(0));for(let i=0;i<n;i++)X[i][0]=1,activeFeatures.forEach((feature,j)=>{const rawValue=data[i][feature.featureKey],transformedValue=this.applyTransformation(rawValue,feature.power);X[i][j+1]=transformedValue});return X}async trainModel(){const activeFeatures=this.getActiveFeatureTransformations();if(0===activeFeatures.length)return void this.resetModel();const X_raw=this.prepareFeatureMatrix(this.fullTrainData),y=this.fullTrainData.map(row=>this.normalizeSaleEstimate(row[this.labelKey])),{X_normalized:X_normalized,featureMeans:featureMeans,featureStds:featureStds}=this.normalizeFeatures(X_raw);try{let theta;theta=this.lassoMode?await this.lassoGradientDescent(X_normalized,y,128,5,this.lambdaStrength):await this.miniBatchGradientDescent(X_normalized,y,128,5),this.model={theta:theta,activeFeatures:activeFeatures,featureMeans:featureMeans,featureStds:featureStds},this.evaluateModel(),this.updateDisplay(),this.updateChart(),this.lassoMode&&this.generateCoefficientVisualization()}catch(error){console.error("Error training model:",error),this.resetModel()}}normalizeFeatures(X){const m=X.length,n=X[0].length,X_normalized=Array(m).fill(null).map(()=>Array(n).fill(0)),featureMeans=new Array(n),featureStds=new Array(n);for(let j=0;j<n;j++)if(0===j){for(let i=0;i<m;i++)X_normalized[i][j]=X[i][j];featureMeans[j]=0,featureStds[j]=1}else{let sum=0;for(let i=0;i<m;i++)sum+=X[i][j];const mean=sum/m;featureMeans[j]=mean;let variance=0;for(let i=0;i<m;i++)variance+=Math.pow(X[i][j]-mean,2);const std=Math.sqrt(variance/m);featureStds[j]=std>0?std:1;for(let i=0;i<m;i++)X_normalized[i][j]=(X[i][j]-mean)/featureStds[j]}return{X_normalized:X_normalized,featureMeans:featureMeans,featureStds:featureStds}}normalizeTestFeatures(X_test,featureMeans,featureStds){const m=X_test.length,n=X_test[0].length,X_normalized=Array(m).fill(null).map(()=>Array(n).fill(0));for(let i=0;i<m;i++)for(let j=0;j<n;j++)X_normalized[i][j]=0===j?X_test[i][j]:(X_test[i][j]-featureMeans[j])/featureStds[j];return X_normalized}async miniBatchGradientDescent(X,y,batchSize,numEpochs){const m=X.length,n=X[0].length;let theta=new Array(n).fill(0);const numBatches=Math.floor(m/batchSize),rng=this.seededRandom(this.randomSeed);console.log(`Training for ${numEpochs} epochs with ${numBatches} batches per epoch (batch_size=${batchSize}, ${m} samples)`);for(let epoch=0;epoch<numEpochs;epoch++){const indices=Array.from({length:m},(_,i)=>i);for(let i=m-1;i>0;i--){const j=Math.floor(rng()*(i+1));[indices[i],indices[j]]=[indices[j],indices[i]]}const X_shuffled=indices.map(i=>X[i]),y_shuffled=indices.map(i=>y[i]);for(let batchIdx=0;batchIdx<numBatches;batchIdx++){if(this.cancelTraining)return console.log("Training cancelled"),theta;const startIdx=batchIdx*batchSize,endIdx=startIdx+batchSize,X_batch=X_shuffled.slice(startIdx,endIdx),y_batch=y_shuffled.slice(startIdx,endIdx),predictions=X_batch.map(row=>theta.reduce((sum,coef,i)=>sum+coef*row[i],0)),gradients=new Array(n).fill(0);for(let j=0;j<n;j++){let gradient=0;for(let i=0;i<batchSize;i++)gradient+=(predictions[i]-y_batch[i])*X_batch[i][j];gradients[j]=gradient/batchSize}for(let j=0;j<n;j++)theta[j]-=.1*gradients[j];const loss=X.map(row=>theta.reduce((sum,coef,i)=>sum+coef*row[i],0)).reduce((sum,pred,i)=>sum+Math.pow(pred-y[i],2),0)/(2*m);this.lossHistory.push(loss);(batchIdx%30==0||epoch===numEpochs-1&&batchIdx===numBatches-1)&&(this.drawLossCurve(),await new Promise(resolve=>setTimeout(resolve,0)))}}return console.log(`Training completed: ${numEpochs} epochs, ${numBatches*numEpochs} steps, ${n} features`),theta}async lassoGradientDescent(X,y,batchSize,numEpochs,lambda){const m=X.length,n=X[0].length;let theta=new Array(n).fill(0);const numBatches=Math.floor(m/batchSize),rng=this.seededRandom(this.randomSeed);console.log(`Training Lasso (Î»=${lambda}) for ${numEpochs} epochs with ${numBatches} batches per epoch (batch_size=${batchSize}, ${m} samples)`);const softThreshold=(w,threshold)=>w>threshold?w-threshold:w<-threshold?w+threshold:0;for(let epoch=0;epoch<numEpochs;epoch++){const indices=Array.from({length:m},(_,i)=>i);for(let i=m-1;i>0;i--){const j=Math.floor(rng()*(i+1));[indices[i],indices[j]]=[indices[j],indices[i]]}const X_shuffled=indices.map(i=>X[i]),y_shuffled=indices.map(i=>y[i]);for(let batchIdx=0;batchIdx<numBatches;batchIdx++){if(this.cancelTraining)return console.log("Lasso training cancelled"),theta;const startIdx=batchIdx*batchSize,endIdx=startIdx+batchSize,X_batch=X_shuffled.slice(startIdx,endIdx),y_batch=y_shuffled.slice(startIdx,endIdx),predictions=X_batch.map(row=>theta.reduce((sum,coef,i)=>sum+coef*row[i],0)),gradients=new Array(n).fill(0);for(let j=0;j<n;j++){let gradient=0;for(let i=0;i<batchSize;i++)gradient+=(predictions[i]-y_batch[i])*X_batch[i][j];gradients[j]=gradient/batchSize}for(let j=0;j<n;j++)theta[j]-=.1*gradients[j];const threshold=.1*lambda;for(let j=1;j<n;j++)theta[j]=softThreshold(theta[j],threshold);const loss=X.map(row=>theta.reduce((sum,coef,i)=>sum+coef*row[i],0)).reduce((sum,pred,i)=>sum+Math.pow(pred-y[i],2),0)/(2*m)+lambda*theta.slice(1).reduce((sum,coef)=>sum+Math.abs(coef),0);this.lossHistory.push(loss);(batchIdx%30==0||epoch===numEpochs-1&&batchIdx===numBatches-1)&&(this.drawLossCurve(),await new Promise(resolve=>setTimeout(resolve,0)))}}return console.log(`Lasso training completed: ${numEpochs} epochs, ${numBatches*numEpochs} steps, ${n} features`),console.log(`Sparsity: ${theta.slice(1).filter(c=>Math.abs(c)<.001).length}/${n-1} coefficients near zero`),theta}evaluateModel(){if(!this.model)return;const X_train_raw=this.prepareFeatureMatrix(this.trainData),train_predictions_normalized=(this.trainData.map(row=>this.normalizeSaleEstimate(row[this.labelKey])),this.normalizeTestFeatures(X_train_raw,this.model.featureMeans,this.model.featureStds).map(row=>this.model.theta.reduce((sum,coef,i)=>sum+coef*row[i],0))),y_train=this.trainData.map(row=>row[this.labelKey]),train_predictions=train_predictions_normalized.map(pred=>this.denormalizeSaleEstimate(pred)),n_train=y_train.length,train_mse=y_train.reduce((sum,actual,i)=>sum+Math.pow(actual-train_predictions[i],2),0)/n_train,train_mae=y_train.reduce((sum,actual,i)=>sum+Math.abs(actual-train_predictions[i]),0)/n_train,y_train_mean=y_train.reduce((sum,val)=>sum+val,0)/n_train,train_ss_tot=y_train.reduce((sum,val)=>sum+Math.pow(val-y_train_mean,2),0),train_r2=1-y_train.reduce((sum,actual,i)=>sum+Math.pow(actual-train_predictions[i],2),0)/train_ss_tot,X_test_raw=this.prepareFeatureMatrix(this.testData),test_predictions_normalized=(this.testData.map(row=>this.normalizeSaleEstimate(row[this.labelKey])),this.normalizeTestFeatures(X_test_raw,this.model.featureMeans,this.model.featureStds).map(row=>this.model.theta.reduce((sum,coef,i)=>sum+coef*row[i],0))),y_test=this.testData.map(row=>row[this.labelKey]),test_predictions=test_predictions_normalized.map(pred=>this.denormalizeSaleEstimate(pred)),n_test=y_test.length,test_mse=y_test.reduce((sum,actual,i)=>sum+Math.pow(actual-test_predictions[i],2),0)/n_test,test_mae=y_test.reduce((sum,actual,i)=>sum+Math.abs(actual-test_predictions[i]),0)/n_test,y_test_mean=y_test.reduce((sum,val)=>sum+val,0)/n_test,test_ss_tot=y_test.reduce((sum,val)=>sum+Math.pow(val-y_test_mean,2),0),test_r2=1-y_test.reduce((sum,actual,i)=>sum+Math.pow(actual-test_predictions[i],2),0)/test_ss_tot;this.model.trainMetrics={mse:train_mse,mae:train_mae,r2:train_r2},this.model.testMetrics={mse:test_mse,mae:test_mae,r2:test_r2},this.model.trainPredictions=train_predictions,this.model.trainActual=y_train,this.model.testPredictions=test_predictions,this.model.testActual=y_test}resetModel(){this.model=null,this.updateDisplay(),this.clearChart()}updateDisplay(){if(this.model){const metrics="train"===this.datasetMode?this.model.trainMetrics:this.model.testMetrics;if(metrics){const mae=metrics.mae/1e3,mse=metrics.mse/1e6,r2=metrics.r2;this.maeDisplay.update(mae),this.mseDisplay.update(mse),this.r2Display.update(r2)}}else this.maeDisplay.update(0),this.mseDisplay.update(0),this.r2Display.update(0)}updateChart(){if(!this.model||!this.chart)return;const trainScatterData=this.model.trainActual.map((actualVal,i)=>({x:actualVal,y:this.model.trainPredictions[i]})),testScatterData=this.model.testActual.map((actualVal,i)=>({x:actualVal,y:this.model.testPredictions[i]})),lineData=[{x:0,y:0},{x:6e6,y:6e6}];this.chart.data.datasets[0].data=trainScatterData,this.chart.data.datasets[1].data=lineData,this.chart.data.datasets[2].data=testScatterData,"train"===this.datasetMode?this.chart.data.datasets[2].hidden=!0:this.chart.data.datasets[2].hidden=!1,this.chart.options.scales.x.min=0,this.chart.options.scales.x.max=6e6,this.chart.options.scales.y.min=0,this.chart.options.scales.y.max=6e6,this.chart.update()}clearChart(){this.chart&&(this.chart.data.datasets[0].data=[],this.chart.data.datasets[1].data=[],this.chart.data.datasets[2].data=[],this.chart.update())}matrixMultiply(A,B){const result=Array(A.length).fill(null).map(()=>Array(B[0].length).fill(0));for(let i=0;i<A.length;i++)for(let j=0;j<B[0].length;j++)for(let k=0;k<B.length;k++)result[i][j]+=A[i][k]*B[k][j];return result}matrixTranspose(A){return A[0].map((_,i)=>A.map(row=>row[i]))}matrixVectorMultiply(A,v){return A.map(row=>row.reduce((sum,val,i)=>sum+val*v[i],0))}matrixInverse(A){const n=A.length,augmented=A.map((row,i)=>[...row,...Array(n).fill(0).map((_,j)=>i===j?1:0)]);for(let i=0;i<n;i++){let maxRow=i;for(let k=i+1;k<n;k++)Math.abs(augmented[k][i])>Math.abs(augmented[maxRow][i])&&(maxRow=k);[augmented[i],augmented[maxRow]]=[augmented[maxRow],augmented[i]];const pivot=augmented[i][i];if(Math.abs(pivot)<1e-10)throw new Error("Matrix is singular");for(let j=0;j<2*n;j++)augmented[i][j]/=pivot;for(let k=0;k<n;k++)if(k!==i){const factor=augmented[k][i];for(let j=0;j<2*n;j++)augmented[k][j]-=factor*augmented[i][j]}}return augmented.map(row=>row.slice(n))}}